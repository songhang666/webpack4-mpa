(window.webpackJsonp=window.webpackJsonp||[]).push([[1],[,function(module,exports,__webpack_require__){"use strict";eval("\n\n__webpack_require__(5)(__webpack_require__(6));\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = window.Zepto;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvX3plcHRvQDEuMi4wQHplcHRvL2Rpc3QvemVwdG8uanM/MGE2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISFEOlxcXFx3ZWJhcHBcXFxcd2VicGFjazQtbXBhXFxcXG5vZGVfbW9kdWxlc1xcXFxfc2NyaXB0LWxvYWRlckAwLjcuMkBzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFEOlxcXFx3ZWJhcHBcXFxcd2VicGFjazQtbXBhXFxcXG5vZGVfbW9kdWxlc1xcXFxfcmF3LWxvYWRlckAwLjUuMUByYXctbG9hZGVyXFxcXGluZGV4LmpzIUQ6XFxcXHdlYmFwcFxcXFx3ZWJwYWNrNC1tcGFcXFxcbm9kZV9tb2R1bGVzXFxcXF96ZXB0b0AxLjIuMEB6ZXB0b1xcXFxkaXN0XFxcXHplcHRvLmpzXCIpKVxuXG4vKioqIEVYUE9SVFMgRlJPTSBleHBvcnRzLWxvYWRlciAqKiovXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5aZXB0bzsiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")},,,,function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== "undefined")\n\t\t&& (console.error || console.log)("[Script Loader]", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== "undefined" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== "undefined") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog("EvalError: No eval function available");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9fc2NyaXB0LWxvYWRlckAwLjcuMkBzY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcz80MzZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xuXHRmdW5jdGlvbiBsb2coZXJyb3IpIHtcblx0XHQodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0JiYgKGNvbnNvbGUuZXJyb3IgfHwgY29uc29sZS5sb2cpKFwiW1NjcmlwdCBMb2FkZXJdXCIsIGVycm9yKTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBJRSA9PCA4XG5cdGZ1bmN0aW9uIGlzSUUoKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBhdHRhY2hFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJ1bmRlZmluZWRcIjtcblx0fVxuXG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiBleGVjU2NyaXB0ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzSUUoKSkge1xuXHRcdFx0ZXhlY1NjcmlwdChzcmMpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGV2YWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGV2YWwuY2FsbChudWxsLCBzcmMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2coXCJFdmFsRXJyb3I6IE5vIGV2YWwgZnVuY3Rpb24gYXZhaWxhYmxlXCIpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRsb2coZXJyb3IpO1xuXHR9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n')},function(module,exports){eval("module.exports = \"/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */\\n(function(global, factory) {\\n  if (typeof define === 'function' && define.amd)\\n    define(function() { return factory(global) })\\n  else\\n    factory(global)\\n}(this, function(window) {\\n  var Zepto = (function() {\\n  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,\\n    document = window.document,\\n    elementDisplay = {}, classCache = {},\\n    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\\n    fragmentRE = /^\\\\s*<(\\\\w+|!)[^>]*>/,\\n    singleTagRE = /^<(\\\\w+)\\\\s*\\\\/?>(?:<\\\\/\\\\1>|)$/,\\n    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\\\w:]+)[^>]*)\\\\/>/ig,\\n    rootNodeRE = /^(?:body|html)$/i,\\n    capitalRE = /([A-Z])/g,\\n\\n    // special attributes that should be get/set via method calls\\n    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\\n\\n    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\\n    table = document.createElement('table'),\\n    tableRow = document.createElement('tr'),\\n    containers = {\\n      'tr': document.createElement('tbody'),\\n      'tbody': table, 'thead': table, 'tfoot': table,\\n      'td': tableRow, 'th': tableRow,\\n      '*': document.createElement('div')\\n    },\\n    readyRE = /complete|loaded|interactive/,\\n    simpleSelectorRE = /^[\\\\w-]*$/,\\n    class2type = {},\\n    toString = class2type.toString,\\n    zepto = {},\\n    camelize, uniq,\\n    tempParent = document.createElement('div'),\\n    propMap = {\\n      'tabindex': 'tabIndex',\\n      'readonly': 'readOnly',\\n      'for': 'htmlFor',\\n      'class': 'className',\\n      'maxlength': 'maxLength',\\n      'cellspacing': 'cellSpacing',\\n      'cellpadding': 'cellPadding',\\n      'rowspan': 'rowSpan',\\n      'colspan': 'colSpan',\\n      'usemap': 'useMap',\\n      'frameborder': 'frameBorder',\\n      'contenteditable': 'contentEditable'\\n    },\\n    isArray = Array.isArray ||\\n      function(object){ return object instanceof Array }\\n\\n  zepto.matches = function(element, selector) {\\n    if (!selector || !element || element.nodeType !== 1) return false\\n    var matchesSelector = element.matches || element.webkitMatchesSelector ||\\n                          element.mozMatchesSelector || element.oMatchesSelector ||\\n                          element.matchesSelector\\n    if (matchesSelector) return matchesSelector.call(element, selector)\\n    // fall back to performing a selector:\\n    var match, parent = element.parentNode, temp = !parent\\n    if (temp) (parent = tempParent).appendChild(element)\\n    match = ~zepto.qsa(parent, selector).indexOf(element)\\n    temp && tempParent.removeChild(element)\\n    return match\\n  }\\n\\n  function type(obj) {\\n    return obj == null ? String(obj) :\\n      class2type[toString.call(obj)] || \\\"object\\\"\\n  }\\n\\n  function isFunction(value) { return type(value) == \\\"function\\\" }\\n  function isWindow(obj)     { return obj != null && obj == obj.window }\\n  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\\n  function isObject(obj)     { return type(obj) == \\\"object\\\" }\\n  function isPlainObject(obj) {\\n    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\\n  }\\n\\n  function likeArray(obj) {\\n    var length = !!obj && 'length' in obj && obj.length,\\n      type = $.type(obj)\\n\\n    return 'function' != type && !isWindow(obj) && (\\n      'array' == type || length === 0 ||\\n        (typeof length == 'number' && length > 0 && (length - 1) in obj)\\n    )\\n  }\\n\\n  function compact(array) { return filter.call(array, function(item){ return item != null }) }\\n  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\\n  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\\n  function dasherize(str) {\\n    return str.replace(/::/g, '/')\\n           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\\n           .replace(/([a-z\\\\d])([A-Z])/g, '$1_$2')\\n           .replace(/_/g, '-')\\n           .toLowerCase()\\n  }\\n  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\\n\\n  function classRE(name) {\\n    return name in classCache ?\\n      classCache[name] : (classCache[name] = new RegExp('(^|\\\\\\\\s)' + name + '(\\\\\\\\s|$)'))\\n  }\\n\\n  function maybeAddPx(name, value) {\\n    return (typeof value == \\\"number\\\" && !cssNumber[dasherize(name)]) ? value + \\\"px\\\" : value\\n  }\\n\\n  function defaultDisplay(nodeName) {\\n    var element, display\\n    if (!elementDisplay[nodeName]) {\\n      element = document.createElement(nodeName)\\n      document.body.appendChild(element)\\n      display = getComputedStyle(element, '').getPropertyValue(\\\"display\\\")\\n      element.parentNode.removeChild(element)\\n      display == \\\"none\\\" && (display = \\\"block\\\")\\n      elementDisplay[nodeName] = display\\n    }\\n    return elementDisplay[nodeName]\\n  }\\n\\n  function children(element) {\\n    return 'children' in element ?\\n      slice.call(element.children) :\\n      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\\n  }\\n\\n  function Z(dom, selector) {\\n    var i, len = dom ? dom.length : 0\\n    for (i = 0; i < len; i++) this[i] = dom[i]\\n    this.length = len\\n    this.selector = selector || ''\\n  }\\n\\n  // `$.zepto.fragment` takes a html string and an optional tag name\\n  // to generate DOM nodes from the given html string.\\n  // The generated DOM nodes are returned as an array.\\n  // This function can be overridden in plugins for example to make\\n  // it compatible with browsers that don't support the DOM fully.\\n  zepto.fragment = function(html, name, properties) {\\n    var dom, nodes, container\\n\\n    // A special case optimization for a single tag\\n    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\\n\\n    if (!dom) {\\n      if (html.replace) html = html.replace(tagExpanderRE, \\\"<$1></$2>\\\")\\n      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\\n      if (!(name in containers)) name = '*'\\n\\n      container = containers[name]\\n      container.innerHTML = '' + html\\n      dom = $.each(slice.call(container.childNodes), function(){\\n        container.removeChild(this)\\n      })\\n    }\\n\\n    if (isPlainObject(properties)) {\\n      nodes = $(dom)\\n      $.each(properties, function(key, value) {\\n        if (methodAttributes.indexOf(key) > -1) nodes[key](value)\\n        else nodes.attr(key, value)\\n      })\\n    }\\n\\n    return dom\\n  }\\n\\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\\n  // to the array. This method can be overridden in plugins.\\n  zepto.Z = function(dom, selector) {\\n    return new Z(dom, selector)\\n  }\\n\\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\\n  // collection. This method can be overridden in plugins.\\n  zepto.isZ = function(object) {\\n    return object instanceof zepto.Z\\n  }\\n\\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\\n  // takes a CSS selector and an optional context (and handles various\\n  // special cases).\\n  // This method can be overridden in plugins.\\n  zepto.init = function(selector, context) {\\n    var dom\\n    // If nothing given, return an empty Zepto collection\\n    if (!selector) return zepto.Z()\\n    // Optimize for string selectors\\n    else if (typeof selector == 'string') {\\n      selector = selector.trim()\\n      // If it's a html fragment, create nodes from it\\n      // Note: In both Chrome 21 and Firefox 15, DOM error 12\\n      // is thrown if the fragment doesn't begin with <\\n      if (selector[0] == '<' && fragmentRE.test(selector))\\n        dom = zepto.fragment(selector, RegExp.$1, context), selector = null\\n      // If there's a context, create a collection on that context first, and select\\n      // nodes from there\\n      else if (context !== undefined) return $(context).find(selector)\\n      // If it's a CSS selector, use it to select nodes.\\n      else dom = zepto.qsa(document, selector)\\n    }\\n    // If a function is given, call it when the DOM is ready\\n    else if (isFunction(selector)) return $(document).ready(selector)\\n    // If a Zepto collection is given, just return it\\n    else if (zepto.isZ(selector)) return selector\\n    else {\\n      // normalize array if an array of nodes is given\\n      if (isArray(selector)) dom = compact(selector)\\n      // Wrap DOM nodes.\\n      else if (isObject(selector))\\n        dom = [selector], selector = null\\n      // If it's a html fragment, create nodes from it\\n      else if (fragmentRE.test(selector))\\n        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\\n      // If there's a context, create a collection on that context first, and select\\n      // nodes from there\\n      else if (context !== undefined) return $(context).find(selector)\\n      // And last but no least, if it's a CSS selector, use it to select nodes.\\n      else dom = zepto.qsa(document, selector)\\n    }\\n    // create a new Zepto collection from the nodes found\\n    return zepto.Z(dom, selector)\\n  }\\n\\n  // `$` will be the base `Zepto` object. When calling this\\n  // function just call `$.zepto.init, which makes the implementation\\n  // details of selecting nodes and creating Zepto collections\\n  // patchable in plugins.\\n  $ = function(selector, context){\\n    return zepto.init(selector, context)\\n  }\\n\\n  function extend(target, source, deep) {\\n    for (key in source)\\n      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\\n        if (isPlainObject(source[key]) && !isPlainObject(target[key]))\\n          target[key] = {}\\n        if (isArray(source[key]) && !isArray(target[key]))\\n          target[key] = []\\n        extend(target[key], source[key], deep)\\n      }\\n      else if (source[key] !== undefined) target[key] = source[key]\\n  }\\n\\n  // Copy all but undefined properties from one or more\\n  // objects to the `target` object.\\n  $.extend = function(target){\\n    var deep, args = slice.call(arguments, 1)\\n    if (typeof target == 'boolean') {\\n      deep = target\\n      target = args.shift()\\n    }\\n    args.forEach(function(arg){ extend(target, arg, deep) })\\n    return target\\n  }\\n\\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\\n  // This method can be overridden in plugins.\\n  zepto.qsa = function(element, selector){\\n    var found,\\n        maybeID = selector[0] == '#',\\n        maybeClass = !maybeID && selector[0] == '.',\\n        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\\n        isSimple = simpleSelectorRE.test(nameOnly)\\n    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById\\n      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\\n      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :\\n      slice.call(\\n        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName\\n          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\\n          element.getElementsByTagName(selector) : // Or a tag\\n          element.querySelectorAll(selector) // Or it's not simple, and we need to query all\\n      )\\n  }\\n\\n  function filtered(nodes, selector) {\\n    return selector == null ? $(nodes) : $(nodes).filter(selector)\\n  }\\n\\n  $.contains = document.documentElement.contains ?\\n    function(parent, node) {\\n      return parent !== node && parent.contains(node)\\n    } :\\n    function(parent, node) {\\n      while (node && (node = node.parentNode))\\n        if (node === parent) return true\\n      return false\\n    }\\n\\n  function funcArg(context, arg, idx, payload) {\\n    return isFunction(arg) ? arg.call(context, idx, payload) : arg\\n  }\\n\\n  function setAttribute(node, name, value) {\\n    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\\n  }\\n\\n  // access className property while respecting SVGAnimatedString\\n  function className(node, value){\\n    var klass = node.className || '',\\n        svg   = klass && klass.baseVal !== undefined\\n\\n    if (value === undefined) return svg ? klass.baseVal : klass\\n    svg ? (klass.baseVal = value) : (node.className = value)\\n  }\\n\\n  // \\\"true\\\"  => true\\n  // \\\"false\\\" => false\\n  // \\\"null\\\"  => null\\n  // \\\"42\\\"    => 42\\n  // \\\"42.5\\\"  => 42.5\\n  // \\\"08\\\"    => \\\"08\\\"\\n  // JSON    => parse if valid\\n  // String  => self\\n  function deserializeValue(value) {\\n    try {\\n      return value ?\\n        value == \\\"true\\\" ||\\n        ( value == \\\"false\\\" ? false :\\n          value == \\\"null\\\" ? null :\\n          +value + \\\"\\\" == value ? +value :\\n          /^[\\\\[\\\\{]/.test(value) ? $.parseJSON(value) :\\n          value )\\n        : value\\n    } catch(e) {\\n      return value\\n    }\\n  }\\n\\n  $.type = type\\n  $.isFunction = isFunction\\n  $.isWindow = isWindow\\n  $.isArray = isArray\\n  $.isPlainObject = isPlainObject\\n\\n  $.isEmptyObject = function(obj) {\\n    var name\\n    for (name in obj) return false\\n    return true\\n  }\\n\\n  $.isNumeric = function(val) {\\n    var num = Number(val), type = typeof val\\n    return val != null && type != 'boolean' &&\\n      (type != 'string' || val.length) &&\\n      !isNaN(num) && isFinite(num) || false\\n  }\\n\\n  $.inArray = function(elem, array, i){\\n    return emptyArray.indexOf.call(array, elem, i)\\n  }\\n\\n  $.camelCase = camelize\\n  $.trim = function(str) {\\n    return str == null ? \\\"\\\" : String.prototype.trim.call(str)\\n  }\\n\\n  // plugin compatibility\\n  $.uuid = 0\\n  $.support = { }\\n  $.expr = { }\\n  $.noop = function() {}\\n\\n  $.map = function(elements, callback){\\n    var value, values = [], i, key\\n    if (likeArray(elements))\\n      for (i = 0; i < elements.length; i++) {\\n        value = callback(elements[i], i)\\n        if (value != null) values.push(value)\\n      }\\n    else\\n      for (key in elements) {\\n        value = callback(elements[key], key)\\n        if (value != null) values.push(value)\\n      }\\n    return flatten(values)\\n  }\\n\\n  $.each = function(elements, callback){\\n    var i, key\\n    if (likeArray(elements)) {\\n      for (i = 0; i < elements.length; i++)\\n        if (callback.call(elements[i], i, elements[i]) === false) return elements\\n    } else {\\n      for (key in elements)\\n        if (callback.call(elements[key], key, elements[key]) === false) return elements\\n    }\\n\\n    return elements\\n  }\\n\\n  $.grep = function(elements, callback){\\n    return filter.call(elements, callback)\\n  }\\n\\n  if (window.JSON) $.parseJSON = JSON.parse\\n\\n  // Populate the class2type map\\n  $.each(\\\"Boolean Number String Function Array Date RegExp Object Error\\\".split(\\\" \\\"), function(i, name) {\\n    class2type[ \\\"[object \\\" + name + \\\"]\\\" ] = name.toLowerCase()\\n  })\\n\\n  // Define methods that will be available on all\\n  // Zepto collections\\n  $.fn = {\\n    constructor: zepto.Z,\\n    length: 0,\\n\\n    // Because a collection acts like an array\\n    // copy over these useful array functions.\\n    forEach: emptyArray.forEach,\\n    reduce: emptyArray.reduce,\\n    push: emptyArray.push,\\n    sort: emptyArray.sort,\\n    splice: emptyArray.splice,\\n    indexOf: emptyArray.indexOf,\\n    concat: function(){\\n      var i, value, args = []\\n      for (i = 0; i < arguments.length; i++) {\\n        value = arguments[i]\\n        args[i] = zepto.isZ(value) ? value.toArray() : value\\n      }\\n      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)\\n    },\\n\\n    // `map` and `slice` in the jQuery API work differently\\n    // from their array counterparts\\n    map: function(fn){\\n      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\\n    },\\n    slice: function(){\\n      return $(slice.apply(this, arguments))\\n    },\\n\\n    ready: function(callback){\\n      // need to check if document.body exists for IE as that browser reports\\n      // document ready when it hasn't yet created the body element\\n      if (readyRE.test(document.readyState) && document.body) callback($)\\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\\n      return this\\n    },\\n    get: function(idx){\\n      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\\n    },\\n    toArray: function(){ return this.get() },\\n    size: function(){\\n      return this.length\\n    },\\n    remove: function(){\\n      return this.each(function(){\\n        if (this.parentNode != null)\\n          this.parentNode.removeChild(this)\\n      })\\n    },\\n    each: function(callback){\\n      emptyArray.every.call(this, function(el, idx){\\n        return callback.call(el, idx, el) !== false\\n      })\\n      return this\\n    },\\n    filter: function(selector){\\n      if (isFunction(selector)) return this.not(this.not(selector))\\n      return $(filter.call(this, function(element){\\n        return zepto.matches(element, selector)\\n      }))\\n    },\\n    add: function(selector,context){\\n      return $(uniq(this.concat($(selector,context))))\\n    },\\n    is: function(selector){\\n      return this.length > 0 && zepto.matches(this[0], selector)\\n    },\\n    not: function(selector){\\n      var nodes=[]\\n      if (isFunction(selector) && selector.call !== undefined)\\n        this.each(function(idx){\\n          if (!selector.call(this,idx)) nodes.push(this)\\n        })\\n      else {\\n        var excludes = typeof selector == 'string' ? this.filter(selector) :\\n          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\\n        this.forEach(function(el){\\n          if (excludes.indexOf(el) < 0) nodes.push(el)\\n        })\\n      }\\n      return $(nodes)\\n    },\\n    has: function(selector){\\n      return this.filter(function(){\\n        return isObject(selector) ?\\n          $.contains(this, selector) :\\n          $(this).find(selector).size()\\n      })\\n    },\\n    eq: function(idx){\\n      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\\n    },\\n    first: function(){\\n      var el = this[0]\\n      return el && !isObject(el) ? el : $(el)\\n    },\\n    last: function(){\\n      var el = this[this.length - 1]\\n      return el && !isObject(el) ? el : $(el)\\n    },\\n    find: function(selector){\\n      var result, $this = this\\n      if (!selector) result = $()\\n      else if (typeof selector == 'object')\\n        result = $(selector).filter(function(){\\n          var node = this\\n          return emptyArray.some.call($this, function(parent){\\n            return $.contains(parent, node)\\n          })\\n        })\\n      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\\n      else result = this.map(function(){ return zepto.qsa(this, selector) })\\n      return result\\n    },\\n    closest: function(selector, context){\\n      var nodes = [], collection = typeof selector == 'object' && $(selector)\\n      this.each(function(_, node){\\n        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\\n          node = node !== context && !isDocument(node) && node.parentNode\\n        if (node && nodes.indexOf(node) < 0) nodes.push(node)\\n      })\\n      return $(nodes)\\n    },\\n    parents: function(selector){\\n      var ancestors = [], nodes = this\\n      while (nodes.length > 0)\\n        nodes = $.map(nodes, function(node){\\n          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\\n            ancestors.push(node)\\n            return node\\n          }\\n        })\\n      return filtered(ancestors, selector)\\n    },\\n    parent: function(selector){\\n      return filtered(uniq(this.pluck('parentNode')), selector)\\n    },\\n    children: function(selector){\\n      return filtered(this.map(function(){ return children(this) }), selector)\\n    },\\n    contents: function() {\\n      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })\\n    },\\n    siblings: function(selector){\\n      return filtered(this.map(function(i, el){\\n        return filter.call(children(el.parentNode), function(child){ return child!==el })\\n      }), selector)\\n    },\\n    empty: function(){\\n      return this.each(function(){ this.innerHTML = '' })\\n    },\\n    // `pluck` is borrowed from Prototype.js\\n    pluck: function(property){\\n      return $.map(this, function(el){ return el[property] })\\n    },\\n    show: function(){\\n      return this.each(function(){\\n        this.style.display == \\\"none\\\" && (this.style.display = '')\\n        if (getComputedStyle(this, '').getPropertyValue(\\\"display\\\") == \\\"none\\\")\\n          this.style.display = defaultDisplay(this.nodeName)\\n      })\\n    },\\n    replaceWith: function(newContent){\\n      return this.before(newContent).remove()\\n    },\\n    wrap: function(structure){\\n      var func = isFunction(structure)\\n      if (this[0] && !func)\\n        var dom   = $(structure).get(0),\\n            clone = dom.parentNode || this.length > 1\\n\\n      return this.each(function(index){\\n        $(this).wrapAll(\\n          func ? structure.call(this, index) :\\n            clone ? dom.cloneNode(true) : dom\\n        )\\n      })\\n    },\\n    wrapAll: function(structure){\\n      if (this[0]) {\\n        $(this[0]).before(structure = $(structure))\\n        var children\\n        // drill down to the inmost element\\n        while ((children = structure.children()).length) structure = children.first()\\n        $(structure).append(this)\\n      }\\n      return this\\n    },\\n    wrapInner: function(structure){\\n      var func = isFunction(structure)\\n      return this.each(function(index){\\n        var self = $(this), contents = self.contents(),\\n            dom  = func ? structure.call(this, index) : structure\\n        contents.length ? contents.wrapAll(dom) : self.append(dom)\\n      })\\n    },\\n    unwrap: function(){\\n      this.parent().each(function(){\\n        $(this).replaceWith($(this).children())\\n      })\\n      return this\\n    },\\n    clone: function(){\\n      return this.map(function(){ return this.cloneNode(true) })\\n    },\\n    hide: function(){\\n      return this.css(\\\"display\\\", \\\"none\\\")\\n    },\\n    toggle: function(setting){\\n      return this.each(function(){\\n        var el = $(this)\\n        ;(setting === undefined ? el.css(\\\"display\\\") == \\\"none\\\" : setting) ? el.show() : el.hide()\\n      })\\n    },\\n    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\\n    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\\n    html: function(html){\\n      return 0 in arguments ?\\n        this.each(function(idx){\\n          var originHtml = this.innerHTML\\n          $(this).empty().append( funcArg(this, html, idx, originHtml) )\\n        }) :\\n        (0 in this ? this[0].innerHTML : null)\\n    },\\n    text: function(text){\\n      return 0 in arguments ?\\n        this.each(function(idx){\\n          var newText = funcArg(this, text, idx, this.textContent)\\n          this.textContent = newText == null ? '' : ''+newText\\n        }) :\\n        (0 in this ? this.pluck('textContent').join(\\\"\\\") : null)\\n    },\\n    attr: function(name, value){\\n      var result\\n      return (typeof name == 'string' && !(1 in arguments)) ?\\n        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :\\n        this.each(function(idx){\\n          if (this.nodeType !== 1) return\\n          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\\n          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\\n        })\\n    },\\n    removeAttr: function(name){\\n      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\\n        setAttribute(this, attribute)\\n      }, this)})\\n    },\\n    prop: function(name, value){\\n      name = propMap[name] || name\\n      return (1 in arguments) ?\\n        this.each(function(idx){\\n          this[name] = funcArg(this, value, idx, this[name])\\n        }) :\\n        (this[0] && this[0][name])\\n    },\\n    removeProp: function(name){\\n      name = propMap[name] || name\\n      return this.each(function(){ delete this[name] })\\n    },\\n    data: function(name, value){\\n      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\\n\\n      var data = (1 in arguments) ?\\n        this.attr(attrName, value) :\\n        this.attr(attrName)\\n\\n      return data !== null ? deserializeValue(data) : undefined\\n    },\\n    val: function(value){\\n      if (0 in arguments) {\\n        if (value == null) value = \\\"\\\"\\n        return this.each(function(idx){\\n          this.value = funcArg(this, value, idx, this.value)\\n        })\\n      } else {\\n        return this[0] && (this[0].multiple ?\\n           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\\n           this[0].value)\\n      }\\n    },\\n    offset: function(coordinates){\\n      if (coordinates) return this.each(function(index){\\n        var $this = $(this),\\n            coords = funcArg(this, coordinates, index, $this.offset()),\\n            parentOffset = $this.offsetParent().offset(),\\n            props = {\\n              top:  coords.top  - parentOffset.top,\\n              left: coords.left - parentOffset.left\\n            }\\n\\n        if ($this.css('position') == 'static') props['position'] = 'relative'\\n        $this.css(props)\\n      })\\n      if (!this.length) return null\\n      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))\\n        return {top: 0, left: 0}\\n      var obj = this[0].getBoundingClientRect()\\n      return {\\n        left: obj.left + window.pageXOffset,\\n        top: obj.top + window.pageYOffset,\\n        width: Math.round(obj.width),\\n        height: Math.round(obj.height)\\n      }\\n    },\\n    css: function(property, value){\\n      if (arguments.length < 2) {\\n        var element = this[0]\\n        if (typeof property == 'string') {\\n          if (!element) return\\n          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)\\n        } else if (isArray(property)) {\\n          if (!element) return\\n          var props = {}\\n          var computedStyle = getComputedStyle(element, '')\\n          $.each(property, function(_, prop){\\n            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\\n          })\\n          return props\\n        }\\n      }\\n\\n      var css = ''\\n      if (type(property) == 'string') {\\n        if (!value && value !== 0)\\n          this.each(function(){ this.style.removeProperty(dasherize(property)) })\\n        else\\n          css = dasherize(property) + \\\":\\\" + maybeAddPx(property, value)\\n      } else {\\n        for (key in property)\\n          if (!property[key] && property[key] !== 0)\\n            this.each(function(){ this.style.removeProperty(dasherize(key)) })\\n          else\\n            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\\n      }\\n\\n      return this.each(function(){ this.style.cssText += ';' + css })\\n    },\\n    index: function(element){\\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\\n    },\\n    hasClass: function(name){\\n      if (!name) return false\\n      return emptyArray.some.call(this, function(el){\\n        return this.test(className(el))\\n      }, classRE(name))\\n    },\\n    addClass: function(name){\\n      if (!name) return this\\n      return this.each(function(idx){\\n        if (!('className' in this)) return\\n        classList = []\\n        var cls = className(this), newName = funcArg(this, name, idx, cls)\\n        newName.split(/\\\\s+/g).forEach(function(klass){\\n          if (!$(this).hasClass(klass)) classList.push(klass)\\n        }, this)\\n        classList.length && className(this, cls + (cls ? \\\" \\\" : \\\"\\\") + classList.join(\\\" \\\"))\\n      })\\n    },\\n    removeClass: function(name){\\n      return this.each(function(idx){\\n        if (!('className' in this)) return\\n        if (name === undefined) return className(this, '')\\n        classList = className(this)\\n        funcArg(this, name, idx, classList).split(/\\\\s+/g).forEach(function(klass){\\n          classList = classList.replace(classRE(klass), \\\" \\\")\\n        })\\n        className(this, classList.trim())\\n      })\\n    },\\n    toggleClass: function(name, when){\\n      if (!name) return this\\n      return this.each(function(idx){\\n        var $this = $(this), names = funcArg(this, name, idx, className(this))\\n        names.split(/\\\\s+/g).forEach(function(klass){\\n          (when === undefined ? !$this.hasClass(klass) : when) ?\\n            $this.addClass(klass) : $this.removeClass(klass)\\n        })\\n      })\\n    },\\n    scrollTop: function(value){\\n      if (!this.length) return\\n      var hasScrollTop = 'scrollTop' in this[0]\\n      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\\n      return this.each(hasScrollTop ?\\n        function(){ this.scrollTop = value } :\\n        function(){ this.scrollTo(this.scrollX, value) })\\n    },\\n    scrollLeft: function(value){\\n      if (!this.length) return\\n      var hasScrollLeft = 'scrollLeft' in this[0]\\n      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\\n      return this.each(hasScrollLeft ?\\n        function(){ this.scrollLeft = value } :\\n        function(){ this.scrollTo(value, this.scrollY) })\\n    },\\n    position: function() {\\n      if (!this.length) return\\n\\n      var elem = this[0],\\n        // Get *real* offsetParent\\n        offsetParent = this.offsetParent(),\\n        // Get correct offsets\\n        offset       = this.offset(),\\n        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\\n\\n      // Subtract element margins\\n      // note: when an element has margin: auto the offsetLeft and marginLeft\\n      // are the same in Safari causing offset.left to incorrectly be 0\\n      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\\n      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\\n\\n      // Add offsetParent borders\\n      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\\n      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\\n\\n      // Subtract the two offsets\\n      return {\\n        top:  offset.top  - parentOffset.top,\\n        left: offset.left - parentOffset.left\\n      }\\n    },\\n    offsetParent: function() {\\n      return this.map(function(){\\n        var parent = this.offsetParent || document.body\\n        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\\\"position\\\") == \\\"static\\\")\\n          parent = parent.offsetParent\\n        return parent\\n      })\\n    }\\n  }\\n\\n  // for now\\n  $.fn.detach = $.fn.remove\\n\\n  // Generate the `width` and `height` functions\\n  ;['width', 'height'].forEach(function(dimension){\\n    var dimensionProperty =\\n      dimension.replace(/./, function(m){ return m[0].toUpperCase() })\\n\\n    $.fn[dimension] = function(value){\\n      var offset, el = this[0]\\n      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\\n        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\\n        (offset = this.offset()) && offset[dimension]\\n      else return this.each(function(idx){\\n        el = $(this)\\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()))\\n      })\\n    }\\n  })\\n\\n  function traverseNode(node, fun) {\\n    fun(node)\\n    for (var i = 0, len = node.childNodes.length; i < len; i++)\\n      traverseNode(node.childNodes[i], fun)\\n  }\\n\\n  // Generate the `after`, `prepend`, `before`, `append`,\\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\\n  adjacencyOperators.forEach(function(operator, operatorIndex) {\\n    var inside = operatorIndex % 2 //=> prepend, append\\n\\n    $.fn[operator] = function(){\\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\\n      var argType, nodes = $.map(arguments, function(arg) {\\n            var arr = []\\n            argType = type(arg)\\n            if (argType == \\\"array\\\") {\\n              arg.forEach(function(el) {\\n                if (el.nodeType !== undefined) return arr.push(el)\\n                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())\\n                arr = arr.concat(zepto.fragment(el))\\n              })\\n              return arr\\n            }\\n            return argType == \\\"object\\\" || arg == null ?\\n              arg : zepto.fragment(arg)\\n          }),\\n          parent, copyByClone = this.length > 1\\n      if (nodes.length < 1) return this\\n\\n      return this.each(function(_, target){\\n        parent = inside ? target : target.parentNode\\n\\n        // convert all methods to a \\\"before\\\" operation\\n        target = operatorIndex == 0 ? target.nextSibling :\\n                 operatorIndex == 1 ? target.firstChild :\\n                 operatorIndex == 2 ? target :\\n                 null\\n\\n        var parentInDocument = $.contains(document.documentElement, parent)\\n\\n        nodes.forEach(function(node){\\n          if (copyByClone) node = node.cloneNode(true)\\n          else if (!parent) return $(node).remove()\\n\\n          parent.insertBefore(node, target)\\n          if (parentInDocument) traverseNode(node, function(el){\\n            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\\n               (!el.type || el.type === 'text/javascript') && !el.src){\\n              var target = el.ownerDocument ? el.ownerDocument.defaultView : window\\n              target['eval'].call(target, el.innerHTML)\\n            }\\n          })\\n        })\\n      })\\n    }\\n\\n    // after    => insertAfter\\n    // prepend  => prependTo\\n    // before   => insertBefore\\n    // append   => appendTo\\n    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\\n      $(html)[operator](this)\\n      return this\\n    }\\n  })\\n\\n  zepto.Z.prototype = Z.prototype = $.fn\\n\\n  // Export internal API functions in the `$.zepto` namespace\\n  zepto.uniq = uniq\\n  zepto.deserializeValue = deserializeValue\\n  $.zepto = zepto\\n\\n  return $\\n})()\\n\\nwindow.Zepto = Zepto\\nwindow.$ === undefined && (window.$ = Zepto)\\n\\n;(function($){\\n  var _zid = 1, undefined,\\n      slice = Array.prototype.slice,\\n      isFunction = $.isFunction,\\n      isString = function(obj){ return typeof obj == 'string' },\\n      handlers = {},\\n      specialEvents={},\\n      focusinSupported = 'onfocusin' in window,\\n      focus = { focus: 'focusin', blur: 'focusout' },\\n      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }\\n\\n  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\\n\\n  function zid(element) {\\n    return element._zid || (element._zid = _zid++)\\n  }\\n  function findHandlers(element, event, fn, selector) {\\n    event = parse(event)\\n    if (event.ns) var matcher = matcherFor(event.ns)\\n    return (handlers[zid(element)] || []).filter(function(handler) {\\n      return handler\\n        && (!event.e  || handler.e == event.e)\\n        && (!event.ns || matcher.test(handler.ns))\\n        && (!fn       || zid(handler.fn) === zid(fn))\\n        && (!selector || handler.sel == selector)\\n    })\\n  }\\n  function parse(event) {\\n    var parts = ('' + event).split('.')\\n    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\\n  }\\n  function matcherFor(ns) {\\n    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\\n  }\\n\\n  function eventCapture(handler, captureSetting) {\\n    return handler.del &&\\n      (!focusinSupported && (handler.e in focus)) ||\\n      !!captureSetting\\n  }\\n\\n  function realEvent(type) {\\n    return hover[type] || (focusinSupported && focus[type]) || type\\n  }\\n\\n  function add(element, events, fn, data, selector, delegator, capture){\\n    var id = zid(element), set = (handlers[id] || (handlers[id] = []))\\n    events.split(/\\\\s/).forEach(function(event){\\n      if (event == 'ready') return $(document).ready(fn)\\n      var handler   = parse(event)\\n      handler.fn    = fn\\n      handler.sel   = selector\\n      // emulate mouseenter, mouseleave\\n      if (handler.e in hover) fn = function(e){\\n        var related = e.relatedTarget\\n        if (!related || (related !== this && !$.contains(this, related)))\\n          return handler.fn.apply(this, arguments)\\n      }\\n      handler.del   = delegator\\n      var callback  = delegator || fn\\n      handler.proxy = function(e){\\n        e = compatible(e)\\n        if (e.isImmediatePropagationStopped()) return\\n        e.data = data\\n        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))\\n        if (result === false) e.preventDefault(), e.stopPropagation()\\n        return result\\n      }\\n      handler.i = set.length\\n      set.push(handler)\\n      if ('addEventListener' in element)\\n        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\\n    })\\n  }\\n  function remove(element, events, fn, selector, capture){\\n    var id = zid(element)\\n    ;(events || '').split(/\\\\s/).forEach(function(event){\\n      findHandlers(element, event, fn, selector).forEach(function(handler){\\n        delete handlers[id][handler.i]\\n      if ('removeEventListener' in element)\\n        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\\n      })\\n    })\\n  }\\n\\n  $.event = { add: add, remove: remove }\\n\\n  $.proxy = function(fn, context) {\\n    var args = (2 in arguments) && slice.call(arguments, 2)\\n    if (isFunction(fn)) {\\n      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }\\n      proxyFn._zid = zid(fn)\\n      return proxyFn\\n    } else if (isString(context)) {\\n      if (args) {\\n        args.unshift(fn[context], fn)\\n        return $.proxy.apply(null, args)\\n      } else {\\n        return $.proxy(fn[context], fn)\\n      }\\n    } else {\\n      throw new TypeError(\\\"expected function\\\")\\n    }\\n  }\\n\\n  $.fn.bind = function(event, data, callback){\\n    return this.on(event, data, callback)\\n  }\\n  $.fn.unbind = function(event, callback){\\n    return this.off(event, callback)\\n  }\\n  $.fn.one = function(event, selector, data, callback){\\n    return this.on(event, selector, data, callback, 1)\\n  }\\n\\n  var returnTrue = function(){return true},\\n      returnFalse = function(){return false},\\n      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,\\n      eventMethods = {\\n        preventDefault: 'isDefaultPrevented',\\n        stopImmediatePropagation: 'isImmediatePropagationStopped',\\n        stopPropagation: 'isPropagationStopped'\\n      }\\n\\n  function compatible(event, source) {\\n    if (source || !event.isDefaultPrevented) {\\n      source || (source = event)\\n\\n      $.each(eventMethods, function(name, predicate) {\\n        var sourceMethod = source[name]\\n        event[name] = function(){\\n          this[predicate] = returnTrue\\n          return sourceMethod && sourceMethod.apply(source, arguments)\\n        }\\n        event[predicate] = returnFalse\\n      })\\n\\n      event.timeStamp || (event.timeStamp = Date.now())\\n\\n      if (source.defaultPrevented !== undefined ? source.defaultPrevented :\\n          'returnValue' in source ? source.returnValue === false :\\n          source.getPreventDefault && source.getPreventDefault())\\n        event.isDefaultPrevented = returnTrue\\n    }\\n    return event\\n  }\\n\\n  function createProxy(event) {\\n    var key, proxy = { originalEvent: event }\\n    for (key in event)\\n      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]\\n\\n    return compatible(proxy, event)\\n  }\\n\\n  $.fn.delegate = function(selector, event, callback){\\n    return this.on(event, selector, callback)\\n  }\\n  $.fn.undelegate = function(selector, event, callback){\\n    return this.off(event, selector, callback)\\n  }\\n\\n  $.fn.live = function(event, callback){\\n    $(document.body).delegate(this.selector, event, callback)\\n    return this\\n  }\\n  $.fn.die = function(event, callback){\\n    $(document.body).undelegate(this.selector, event, callback)\\n    return this\\n  }\\n\\n  $.fn.on = function(event, selector, data, callback, one){\\n    var autoRemove, delegator, $this = this\\n    if (event && !isString(event)) {\\n      $.each(event, function(type, fn){\\n        $this.on(type, selector, data, fn, one)\\n      })\\n      return $this\\n    }\\n\\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\\n      callback = data, data = selector, selector = undefined\\n    if (callback === undefined || data === false)\\n      callback = data, data = undefined\\n\\n    if (callback === false) callback = returnFalse\\n\\n    return $this.each(function(_, element){\\n      if (one) autoRemove = function(e){\\n        remove(element, e.type, callback)\\n        return callback.apply(this, arguments)\\n      }\\n\\n      if (selector) delegator = function(e){\\n        var evt, match = $(e.target).closest(selector, element).get(0)\\n        if (match && match !== element) {\\n          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\\n          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))\\n        }\\n      }\\n\\n      add(element, event, callback, data, selector, delegator || autoRemove)\\n    })\\n  }\\n  $.fn.off = function(event, selector, callback){\\n    var $this = this\\n    if (event && !isString(event)) {\\n      $.each(event, function(type, fn){\\n        $this.off(type, selector, fn)\\n      })\\n      return $this\\n    }\\n\\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\\n      callback = selector, selector = undefined\\n\\n    if (callback === false) callback = returnFalse\\n\\n    return $this.each(function(){\\n      remove(this, event, callback, selector)\\n    })\\n  }\\n\\n  $.fn.trigger = function(event, args){\\n    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)\\n    event._args = args\\n    return this.each(function(){\\n      // handle focus(), blur() by calling them directly\\n      if (event.type in focus && typeof this[event.type] == \\\"function\\\") this[event.type]()\\n      // items in the collection might not be DOM elements\\n      else if ('dispatchEvent' in this) this.dispatchEvent(event)\\n      else $(this).triggerHandler(event, args)\\n    })\\n  }\\n\\n  // triggers event handlers on current element just as if an event occurred,\\n  // doesn't trigger an actual event, doesn't bubble\\n  $.fn.triggerHandler = function(event, args){\\n    var e, result\\n    this.each(function(i, element){\\n      e = createProxy(isString(event) ? $.Event(event) : event)\\n      e._args = args\\n      e.target = element\\n      $.each(findHandlers(element, event.type || event), function(i, handler){\\n        result = handler.proxy(e)\\n        if (e.isImmediatePropagationStopped()) return false\\n      })\\n    })\\n    return result\\n  }\\n\\n  // shortcut methods for `.bind(event, fn)` for each event type\\n  ;('focusin focusout focus blur load resize scroll unload click dblclick '+\\n  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+\\n  'change select keydown keypress keyup error').split(' ').forEach(function(event) {\\n    $.fn[event] = function(callback) {\\n      return (0 in arguments) ?\\n        this.bind(event, callback) :\\n        this.trigger(event)\\n    }\\n  })\\n\\n  $.Event = function(type, props) {\\n    if (!isString(type)) props = type, type = props.type\\n    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\\n    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\\n    event.initEvent(type, bubbles, true)\\n    return compatible(event)\\n  }\\n\\n})(Zepto)\\n\\n;(function($){\\n  var jsonpID = +new Date(),\\n      document = window.document,\\n      key,\\n      name,\\n      rscript = /<script\\\\b[^<]*(?:(?!<\\\\/script>)<[^<]*)*<\\\\/script>/gi,\\n      scriptTypeRE = /^(?:text|application)\\\\/javascript/i,\\n      xmlTypeRE = /^(?:text|application)\\\\/xml/i,\\n      jsonType = 'application/json',\\n      htmlType = 'text/html',\\n      blankRE = /^\\\\s*$/,\\n      originAnchor = document.createElement('a')\\n\\n  originAnchor.href = window.location.href\\n\\n  // trigger a custom event and return false if it was cancelled\\n  function triggerAndReturn(context, eventName, data) {\\n    var event = $.Event(eventName)\\n    $(context).trigger(event, data)\\n    return !event.isDefaultPrevented()\\n  }\\n\\n  // trigger an Ajax \\\"global\\\" event\\n  function triggerGlobal(settings, context, eventName, data) {\\n    if (settings.global) return triggerAndReturn(context || document, eventName, data)\\n  }\\n\\n  // Number of active Ajax requests\\n  $.active = 0\\n\\n  function ajaxStart(settings) {\\n    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')\\n  }\\n  function ajaxStop(settings) {\\n    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')\\n  }\\n\\n  // triggers an extra global event \\\"ajaxBeforeSend\\\" that's like \\\"ajaxSend\\\" but cancelable\\n  function ajaxBeforeSend(xhr, settings) {\\n    var context = settings.context\\n    if (settings.beforeSend.call(context, xhr, settings) === false ||\\n        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)\\n      return false\\n\\n    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])\\n  }\\n  function ajaxSuccess(data, xhr, settings, deferred) {\\n    var context = settings.context, status = 'success'\\n    settings.success.call(context, data, status, xhr)\\n    if (deferred) deferred.resolveWith(context, [data, status, xhr])\\n    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])\\n    ajaxComplete(status, xhr, settings)\\n  }\\n  // type: \\\"timeout\\\", \\\"error\\\", \\\"abort\\\", \\\"parsererror\\\"\\n  function ajaxError(error, type, xhr, settings, deferred) {\\n    var context = settings.context\\n    settings.error.call(context, xhr, type, error)\\n    if (deferred) deferred.rejectWith(context, [xhr, type, error])\\n    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])\\n    ajaxComplete(type, xhr, settings)\\n  }\\n  // status: \\\"success\\\", \\\"notmodified\\\", \\\"error\\\", \\\"timeout\\\", \\\"abort\\\", \\\"parsererror\\\"\\n  function ajaxComplete(status, xhr, settings) {\\n    var context = settings.context\\n    settings.complete.call(context, xhr, status)\\n    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])\\n    ajaxStop(settings)\\n  }\\n\\n  function ajaxDataFilter(data, type, settings) {\\n    if (settings.dataFilter == empty) return data\\n    var context = settings.context\\n    return settings.dataFilter.call(context, data, type)\\n  }\\n\\n  // Empty function, used as default callback\\n  function empty() {}\\n\\n  $.ajaxJSONP = function(options, deferred){\\n    if (!('type' in options)) return $.ajax(options)\\n\\n    var _callbackName = options.jsonpCallback,\\n      callbackName = ($.isFunction(_callbackName) ?\\n        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),\\n      script = document.createElement('script'),\\n      originalCallback = window[callbackName],\\n      responseData,\\n      abort = function(errorType) {\\n        $(script).triggerHandler('error', errorType || 'abort')\\n      },\\n      xhr = { abort: abort }, abortTimeout\\n\\n    if (deferred) deferred.promise(xhr)\\n\\n    $(script).on('load error', function(e, errorType){\\n      clearTimeout(abortTimeout)\\n      $(script).off().remove()\\n\\n      if (e.type == 'error' || !responseData) {\\n        ajaxError(null, errorType || 'error', xhr, options, deferred)\\n      } else {\\n        ajaxSuccess(responseData[0], xhr, options, deferred)\\n      }\\n\\n      window[callbackName] = originalCallback\\n      if (responseData && $.isFunction(originalCallback))\\n        originalCallback(responseData[0])\\n\\n      originalCallback = responseData = undefined\\n    })\\n\\n    if (ajaxBeforeSend(xhr, options) === false) {\\n      abort('abort')\\n      return xhr\\n    }\\n\\n    window[callbackName] = function(){\\n      responseData = arguments\\n    }\\n\\n    script.src = options.url.replace(/\\\\?(.+)=\\\\?/, '?$1=' + callbackName)\\n    document.head.appendChild(script)\\n\\n    if (options.timeout > 0) abortTimeout = setTimeout(function(){\\n      abort('timeout')\\n    }, options.timeout)\\n\\n    return xhr\\n  }\\n\\n  $.ajaxSettings = {\\n    // Default type of request\\n    type: 'GET',\\n    // Callback that is executed before request\\n    beforeSend: empty,\\n    // Callback that is executed if the request succeeds\\n    success: empty,\\n    // Callback that is executed the the server drops error\\n    error: empty,\\n    // Callback that is executed on request complete (both: error and success)\\n    complete: empty,\\n    // The context for the callbacks\\n    context: null,\\n    // Whether to trigger \\\"global\\\" Ajax events\\n    global: true,\\n    // Transport\\n    xhr: function () {\\n      return new window.XMLHttpRequest()\\n    },\\n    // MIME types mapping\\n    // IIS returns Javascript as \\\"application/x-javascript\\\"\\n    accepts: {\\n      script: 'text/javascript, application/javascript, application/x-javascript',\\n      json:   jsonType,\\n      xml:    'application/xml, text/xml',\\n      html:   htmlType,\\n      text:   'text/plain'\\n    },\\n    // Whether the request is to another domain\\n    crossDomain: false,\\n    // Default timeout\\n    timeout: 0,\\n    // Whether data should be serialized to string\\n    processData: true,\\n    // Whether the browser should be allowed to cache GET responses\\n    cache: true,\\n    //Used to handle the raw response data of XMLHttpRequest.\\n    //This is a pre-filtering function to sanitize the response.\\n    //The sanitized response should be returned\\n    dataFilter: empty\\n  }\\n\\n  function mimeToDataType(mime) {\\n    if (mime) mime = mime.split(';', 2)[0]\\n    return mime && ( mime == htmlType ? 'html' :\\n      mime == jsonType ? 'json' :\\n      scriptTypeRE.test(mime) ? 'script' :\\n      xmlTypeRE.test(mime) && 'xml' ) || 'text'\\n  }\\n\\n  function appendQuery(url, query) {\\n    if (query == '') return url\\n    return (url + '&' + query).replace(/[&?]{1,2}/, '?')\\n  }\\n\\n  // serialize payload and append it to the URL for GET requests\\n  function serializeData(options) {\\n    if (options.processData && options.data && $.type(options.data) != \\\"string\\\")\\n      options.data = $.param(options.data, options.traditional)\\n    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))\\n      options.url = appendQuery(options.url, options.data), options.data = undefined\\n  }\\n\\n  $.ajax = function(options){\\n    var settings = $.extend({}, options || {}),\\n        deferred = $.Deferred && $.Deferred(),\\n        urlAnchor, hashIndex\\n    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]\\n\\n    ajaxStart(settings)\\n\\n    if (!settings.crossDomain) {\\n      urlAnchor = document.createElement('a')\\n      urlAnchor.href = settings.url\\n      // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049\\n      urlAnchor.href = urlAnchor.href\\n      settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)\\n    }\\n\\n    if (!settings.url) settings.url = window.location.toString()\\n    if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)\\n    serializeData(settings)\\n\\n    var dataType = settings.dataType, hasPlaceholder = /\\\\?.+=\\\\?/.test(settings.url)\\n    if (hasPlaceholder) dataType = 'jsonp'\\n\\n    if (settings.cache === false || (\\n         (!options || options.cache !== true) &&\\n         ('script' == dataType || 'jsonp' == dataType)\\n        ))\\n      settings.url = appendQuery(settings.url, '_=' + Date.now())\\n\\n    if ('jsonp' == dataType) {\\n      if (!hasPlaceholder)\\n        settings.url = appendQuery(settings.url,\\n          settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')\\n      return $.ajaxJSONP(settings, deferred)\\n    }\\n\\n    var mime = settings.accepts[dataType],\\n        headers = { },\\n        setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },\\n        protocol = /^([\\\\w-]+:)\\\\/\\\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\\n        xhr = settings.xhr(),\\n        nativeSetHeader = xhr.setRequestHeader,\\n        abortTimeout\\n\\n    if (deferred) deferred.promise(xhr)\\n\\n    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')\\n    setHeader('Accept', mime || '*/*')\\n    if (mime = settings.mimeType || mime) {\\n      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]\\n      xhr.overrideMimeType && xhr.overrideMimeType(mime)\\n    }\\n    if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))\\n      setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')\\n\\n    if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])\\n    xhr.setRequestHeader = setHeader\\n\\n    xhr.onreadystatechange = function(){\\n      if (xhr.readyState == 4) {\\n        xhr.onreadystatechange = empty\\n        clearTimeout(abortTimeout)\\n        var result, error = false\\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {\\n          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))\\n\\n          if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')\\n            result = xhr.response\\n          else {\\n            result = xhr.responseText\\n\\n            try {\\n              // http://perfectionkills.com/global-eval-what-are-the-options/\\n              // sanitize response accordingly if data filter callback provided\\n              result = ajaxDataFilter(result, dataType, settings)\\n              if (dataType == 'script')    (1,eval)(result)\\n              else if (dataType == 'xml')  result = xhr.responseXML\\n              else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)\\n            } catch (e) { error = e }\\n\\n            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred)\\n          }\\n\\n          ajaxSuccess(result, xhr, settings, deferred)\\n        } else {\\n          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)\\n        }\\n      }\\n    }\\n\\n    if (ajaxBeforeSend(xhr, settings) === false) {\\n      xhr.abort()\\n      ajaxError(null, 'abort', xhr, settings, deferred)\\n      return xhr\\n    }\\n\\n    var async = 'async' in settings ? settings.async : true\\n    xhr.open(settings.type, settings.url, async, settings.username, settings.password)\\n\\n    if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]\\n\\n    for (name in headers) nativeSetHeader.apply(xhr, headers[name])\\n\\n    if (settings.timeout > 0) abortTimeout = setTimeout(function(){\\n        xhr.onreadystatechange = empty\\n        xhr.abort()\\n        ajaxError(null, 'timeout', xhr, settings, deferred)\\n      }, settings.timeout)\\n\\n    // avoid sending empty string (#319)\\n    xhr.send(settings.data ? settings.data : null)\\n    return xhr\\n  }\\n\\n  // handle optional data/success arguments\\n  function parseArguments(url, data, success, dataType) {\\n    if ($.isFunction(data)) dataType = success, success = data, data = undefined\\n    if (!$.isFunction(success)) dataType = success, success = undefined\\n    return {\\n      url: url\\n    , data: data\\n    , success: success\\n    , dataType: dataType\\n    }\\n  }\\n\\n  $.get = function(/* url, data, success, dataType */){\\n    return $.ajax(parseArguments.apply(null, arguments))\\n  }\\n\\n  $.post = function(/* url, data, success, dataType */){\\n    var options = parseArguments.apply(null, arguments)\\n    options.type = 'POST'\\n    return $.ajax(options)\\n  }\\n\\n  $.getJSON = function(/* url, data, success */){\\n    var options = parseArguments.apply(null, arguments)\\n    options.dataType = 'json'\\n    return $.ajax(options)\\n  }\\n\\n  $.fn.load = function(url, data, success){\\n    if (!this.length) return this\\n    var self = this, parts = url.split(/\\\\s/), selector,\\n        options = parseArguments(url, data, success),\\n        callback = options.success\\n    if (parts.length > 1) options.url = parts[0], selector = parts[1]\\n    options.success = function(response){\\n      self.html(selector ?\\n        $('<div>').html(response.replace(rscript, \\\"\\\")).find(selector)\\n        : response)\\n      callback && callback.apply(self, arguments)\\n    }\\n    $.ajax(options)\\n    return this\\n  }\\n\\n  var escape = encodeURIComponent\\n\\n  function serialize(params, obj, traditional, scope){\\n    var type, array = $.isArray(obj), hash = $.isPlainObject(obj)\\n    $.each(obj, function(key, value) {\\n      type = $.type(value)\\n      if (scope) key = traditional ? scope :\\n        scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'\\n      // handle data in serializeArray() format\\n      if (!scope && array) params.add(value.name, value.value)\\n      // recurse into nested objects\\n      else if (type == \\\"array\\\" || (!traditional && type == \\\"object\\\"))\\n        serialize(params, value, traditional, key)\\n      else params.add(key, value)\\n    })\\n  }\\n\\n  $.param = function(obj, traditional){\\n    var params = []\\n    params.add = function(key, value) {\\n      if ($.isFunction(value)) value = value()\\n      if (value == null) value = \\\"\\\"\\n      this.push(escape(key) + '=' + escape(value))\\n    }\\n    serialize(params, obj, traditional)\\n    return params.join('&').replace(/%20/g, '+')\\n  }\\n})(Zepto)\\n\\n;(function($){\\n  $.fn.serializeArray = function() {\\n    var name, type, result = [],\\n      add = function(value) {\\n        if (value.forEach) return value.forEach(add)\\n        result.push({ name: name, value: value })\\n      }\\n    if (this[0]) $.each(this[0].elements, function(_, field){\\n      type = field.type, name = field.name\\n      if (name && field.nodeName.toLowerCase() != 'fieldset' &&\\n        !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&\\n        ((type != 'radio' && type != 'checkbox') || field.checked))\\n          add($(field).val())\\n    })\\n    return result\\n  }\\n\\n  $.fn.serialize = function(){\\n    var result = []\\n    this.serializeArray().forEach(function(elm){\\n      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))\\n    })\\n    return result.join('&')\\n  }\\n\\n  $.fn.submit = function(callback) {\\n    if (0 in arguments) this.bind('submit', callback)\\n    else if (this.length) {\\n      var event = $.Event('submit')\\n      this.eq(0).trigger(event)\\n      if (!event.isDefaultPrevented()) this.get(0).submit()\\n    }\\n    return this\\n  }\\n\\n})(Zepto)\\n\\n;(function(){\\n  // getComputedStyle shouldn't freak out when called\\n  // without a valid element as argument\\n  try {\\n    getComputedStyle(undefined)\\n  } catch(e) {\\n    var nativeGetComputedStyle = getComputedStyle\\n    window.getComputedStyle = function(element, pseudoElement){\\n      try {\\n        return nativeGetComputedStyle(element, pseudoElement)\\n      } catch(e) {\\n        return null\\n      }\\n    }\\n  }\\n})()\\n  return Zepto\\n}))\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9femVwdG9AMS4yLjBAemVwdG8vZGlzdC96ZXB0by5qcz9kMDExIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiBaZXB0byB2MS4yLjAgLSB6ZXB0byBldmVudCBhamF4IGZvcm0gaWUgLSB6ZXB0b2pzLmNvbS9saWNlbnNlICovXFxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFjdG9yeShnbG9iYWwpIH0pXFxuICBlbHNlXFxuICAgIGZhY3RvcnkoZ2xvYmFsKVxcbn0odGhpcywgZnVuY3Rpb24od2luZG93KSB7XFxuICB2YXIgWmVwdG8gPSAoZnVuY3Rpb24oKSB7XFxuICB2YXIgdW5kZWZpbmVkLCBrZXksICQsIGNsYXNzTGlzdCwgZW1wdHlBcnJheSA9IFtdLCBjb25jYXQgPSBlbXB0eUFycmF5LmNvbmNhdCwgZmlsdGVyID0gZW1wdHlBcnJheS5maWx0ZXIsIHNsaWNlID0gZW1wdHlBcnJheS5zbGljZSxcXG4gICAgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXFxuICAgIGVsZW1lbnREaXNwbGF5ID0ge30sIGNsYXNzQ2FjaGUgPSB7fSxcXG4gICAgY3NzTnVtYmVyID0geyAnY29sdW1uLWNvdW50JzogMSwgJ2NvbHVtbnMnOiAxLCAnZm9udC13ZWlnaHQnOiAxLCAnbGluZS1oZWlnaHQnOiAxLCdvcGFjaXR5JzogMSwgJ3otaW5kZXgnOiAxLCAnem9vbSc6IDEgfSxcXG4gICAgZnJhZ21lbnRSRSA9IC9eXFxcXHMqPChcXFxcdyt8ISlbXj5dKj4vLFxcbiAgICBzaW5nbGVUYWdSRSA9IC9ePChcXFxcdyspXFxcXHMqXFxcXC8/Pig/OjxcXFxcL1xcXFwxPnwpJC8sXFxuICAgIHRhZ0V4cGFuZGVyUkUgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFxcXHc6XSspW14+XSopXFxcXC8+L2lnLFxcbiAgICByb290Tm9kZVJFID0gL14oPzpib2R5fGh0bWwpJC9pLFxcbiAgICBjYXBpdGFsUkUgPSAvKFtBLVpdKS9nLFxcblxcbiAgICAvLyBzcGVjaWFsIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgZ2V0L3NldCB2aWEgbWV0aG9kIGNhbGxzXFxuICAgIG1ldGhvZEF0dHJpYnV0ZXMgPSBbJ3ZhbCcsICdjc3MnLCAnaHRtbCcsICd0ZXh0JywgJ2RhdGEnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ29mZnNldCddLFxcblxcbiAgICBhZGphY2VuY3lPcGVyYXRvcnMgPSBbICdhZnRlcicsICdwcmVwZW5kJywgJ2JlZm9yZScsICdhcHBlbmQnIF0sXFxuICAgIHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKSxcXG4gICAgdGFibGVSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpLFxcbiAgICBjb250YWluZXJzID0ge1xcbiAgICAgICd0cic6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Rib2R5JyksXFxuICAgICAgJ3Rib2R5JzogdGFibGUsICd0aGVhZCc6IHRhYmxlLCAndGZvb3QnOiB0YWJsZSxcXG4gICAgICAndGQnOiB0YWJsZVJvdywgJ3RoJzogdGFibGVSb3csXFxuICAgICAgJyonOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxcbiAgICB9LFxcbiAgICByZWFkeVJFID0gL2NvbXBsZXRlfGxvYWRlZHxpbnRlcmFjdGl2ZS8sXFxuICAgIHNpbXBsZVNlbGVjdG9yUkUgPSAvXltcXFxcdy1dKiQvLFxcbiAgICBjbGFzczJ0eXBlID0ge30sXFxuICAgIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZyxcXG4gICAgemVwdG8gPSB7fSxcXG4gICAgY2FtZWxpemUsIHVuaXEsXFxuICAgIHRlbXBQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcXG4gICAgcHJvcE1hcCA9IHtcXG4gICAgICAndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxcbiAgICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXFxuICAgICAgJ2Zvcic6ICdodG1sRm9yJyxcXG4gICAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcXG4gICAgICAnbWF4bGVuZ3RoJzogJ21heExlbmd0aCcsXFxuICAgICAgJ2NlbGxzcGFjaW5nJzogJ2NlbGxTcGFjaW5nJyxcXG4gICAgICAnY2VsbHBhZGRpbmcnOiAnY2VsbFBhZGRpbmcnLFxcbiAgICAgICdyb3dzcGFuJzogJ3Jvd1NwYW4nLFxcbiAgICAgICdjb2xzcGFuJzogJ2NvbFNwYW4nLFxcbiAgICAgICd1c2VtYXAnOiAndXNlTWFwJyxcXG4gICAgICAnZnJhbWVib3JkZXInOiAnZnJhbWVCb3JkZXInLFxcbiAgICAgICdjb250ZW50ZWRpdGFibGUnOiAnY29udGVudEVkaXRhYmxlJ1xcbiAgICB9LFxcbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fFxcbiAgICAgIGZ1bmN0aW9uKG9iamVjdCl7IHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBBcnJheSB9XFxuXFxuICB6ZXB0by5tYXRjaGVzID0gZnVuY3Rpb24oZWxlbWVudCwgc2VsZWN0b3IpIHtcXG4gICAgaWYgKCFzZWxlY3RvciB8fCAhZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSByZXR1cm4gZmFsc2VcXG4gICAgdmFyIG1hdGNoZXNTZWxlY3RvciA9IGVsZW1lbnQubWF0Y2hlcyB8fCBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZWxlbWVudC5vTWF0Y2hlc1NlbGVjdG9yIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm1hdGNoZXNTZWxlY3RvclxcbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKSByZXR1cm4gbWF0Y2hlc1NlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpXFxuICAgIC8vIGZhbGwgYmFjayB0byBwZXJmb3JtaW5nIGEgc2VsZWN0b3I6XFxuICAgIHZhciBtYXRjaCwgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlLCB0ZW1wID0gIXBhcmVudFxcbiAgICBpZiAodGVtcCkgKHBhcmVudCA9IHRlbXBQYXJlbnQpLmFwcGVuZENoaWxkKGVsZW1lbnQpXFxuICAgIG1hdGNoID0gfnplcHRvLnFzYShwYXJlbnQsIHNlbGVjdG9yKS5pbmRleE9mKGVsZW1lbnQpXFxuICAgIHRlbXAgJiYgdGVtcFBhcmVudC5yZW1vdmVDaGlsZChlbGVtZW50KVxcbiAgICByZXR1cm4gbWF0Y2hcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHR5cGUob2JqKSB7XFxuICAgIHJldHVybiBvYmogPT0gbnVsbCA/IFN0cmluZyhvYmopIDpcXG4gICAgICBjbGFzczJ0eXBlW3RvU3RyaW5nLmNhbGwob2JqKV0gfHwgXFxcIm9iamVjdFxcXCJcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHR5cGUodmFsdWUpID09IFxcXCJmdW5jdGlvblxcXCIgfVxcbiAgZnVuY3Rpb24gaXNXaW5kb3cob2JqKSAgICAgeyByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09IG9iai53aW5kb3cgfVxcbiAgZnVuY3Rpb24gaXNEb2N1bWVudChvYmopICAgeyByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqLm5vZGVUeXBlID09IG9iai5ET0NVTUVOVF9OT0RFIH1cXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikgICAgIHsgcmV0dXJuIHR5cGUob2JqKSA9PSBcXFwib2JqZWN0XFxcIiB9XFxuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqKSAmJiAhaXNXaW5kb3cob2JqKSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PSBPYmplY3QucHJvdG90eXBlXFxuICB9XFxuXFxuICBmdW5jdGlvbiBsaWtlQXJyYXkob2JqKSB7XFxuICAgIHZhciBsZW5ndGggPSAhIW9iaiAmJiAnbGVuZ3RoJyBpbiBvYmogJiYgb2JqLmxlbmd0aCxcXG4gICAgICB0eXBlID0gJC50eXBlKG9iailcXG5cXG4gICAgcmV0dXJuICdmdW5jdGlvbicgIT0gdHlwZSAmJiAhaXNXaW5kb3cob2JqKSAmJiAoXFxuICAgICAgJ2FycmF5JyA9PSB0eXBlIHx8IGxlbmd0aCA9PT0gMCB8fFxcbiAgICAgICAgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID4gMCAmJiAobGVuZ3RoIC0gMSkgaW4gb2JqKVxcbiAgICApXFxuICB9XFxuXFxuICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7IHJldHVybiBmaWx0ZXIuY2FsbChhcnJheSwgZnVuY3Rpb24oaXRlbSl7IHJldHVybiBpdGVtICE9IG51bGwgfSkgfVxcbiAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkgeyByZXR1cm4gYXJyYXkubGVuZ3RoID4gMCA/ICQuZm4uY29uY2F0LmFwcGx5KFtdLCBhcnJheSkgOiBhcnJheSB9XFxuICBjYW1lbGl6ZSA9IGZ1bmN0aW9uKHN0cil7IHJldHVybiBzdHIucmVwbGFjZSgvLSsoLik/L2csIGZ1bmN0aW9uKG1hdGNoLCBjaHIpeyByZXR1cm4gY2hyID8gY2hyLnRvVXBwZXJDYXNlKCkgOiAnJyB9KSB9XFxuICBmdW5jdGlvbiBkYXNoZXJpemUoc3RyKSB7XFxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvOjovZywgJy8nKVxcbiAgICAgICAgICAgLnJlcGxhY2UoLyhbQS1aXSspKFtBLVpdW2Etel0pL2csICckMV8kMicpXFxuICAgICAgICAgICAucmVwbGFjZSgvKFthLXpcXFxcZF0pKFtBLVpdKS9nLCAnJDFfJDInKVxcbiAgICAgICAgICAgLnJlcGxhY2UoL18vZywgJy0nKVxcbiAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcXG4gIH1cXG4gIHVuaXEgPSBmdW5jdGlvbihhcnJheSl7IHJldHVybiBmaWx0ZXIuY2FsbChhcnJheSwgZnVuY3Rpb24oaXRlbSwgaWR4KXsgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgPT0gaWR4IH0pIH1cXG5cXG4gIGZ1bmN0aW9uIGNsYXNzUkUobmFtZSkge1xcbiAgICByZXR1cm4gbmFtZSBpbiBjbGFzc0NhY2hlID9cXG4gICAgICBjbGFzc0NhY2hlW25hbWVdIDogKGNsYXNzQ2FjaGVbbmFtZV0gPSBuZXcgUmVnRXhwKCcoXnxcXFxcXFxcXHMpJyArIG5hbWUgKyAnKFxcXFxcXFxcc3wkKScpKVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gbWF5YmVBZGRQeChuYW1lLCB2YWx1ZSkge1xcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PSBcXFwibnVtYmVyXFxcIiAmJiAhY3NzTnVtYmVyW2Rhc2hlcml6ZShuYW1lKV0pID8gdmFsdWUgKyBcXFwicHhcXFwiIDogdmFsdWVcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KG5vZGVOYW1lKSB7XFxuICAgIHZhciBlbGVtZW50LCBkaXNwbGF5XFxuICAgIGlmICghZWxlbWVudERpc3BsYXlbbm9kZU5hbWVdKSB7XFxuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpXFxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KVxcbiAgICAgIGRpc3BsYXkgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKFxcXCJkaXNwbGF5XFxcIilcXG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudClcXG4gICAgICBkaXNwbGF5ID09IFxcXCJub25lXFxcIiAmJiAoZGlzcGxheSA9IFxcXCJibG9ja1xcXCIpXFxuICAgICAgZWxlbWVudERpc3BsYXlbbm9kZU5hbWVdID0gZGlzcGxheVxcbiAgICB9XFxuICAgIHJldHVybiBlbGVtZW50RGlzcGxheVtub2RlTmFtZV1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcXG4gICAgcmV0dXJuICdjaGlsZHJlbicgaW4gZWxlbWVudCA/XFxuICAgICAgc2xpY2UuY2FsbChlbGVtZW50LmNoaWxkcmVuKSA6XFxuICAgICAgJC5tYXAoZWxlbWVudC5jaGlsZE5vZGVzLCBmdW5jdGlvbihub2RlKXsgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkgcmV0dXJuIG5vZGUgfSlcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIFooZG9tLCBzZWxlY3Rvcikge1xcbiAgICB2YXIgaSwgbGVuID0gZG9tID8gZG9tLmxlbmd0aCA6IDBcXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB0aGlzW2ldID0gZG9tW2ldXFxuICAgIHRoaXMubGVuZ3RoID0gbGVuXFxuICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvciB8fCAnJ1xcbiAgfVxcblxcbiAgLy8gYCQuemVwdG8uZnJhZ21lbnRgIHRha2VzIGEgaHRtbCBzdHJpbmcgYW5kIGFuIG9wdGlvbmFsIHRhZyBuYW1lXFxuICAvLyB0byBnZW5lcmF0ZSBET00gbm9kZXMgZnJvbSB0aGUgZ2l2ZW4gaHRtbCBzdHJpbmcuXFxuICAvLyBUaGUgZ2VuZXJhdGVkIERPTSBub2RlcyBhcmUgcmV0dXJuZWQgYXMgYW4gYXJyYXkuXFxuICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBvdmVycmlkZGVuIGluIHBsdWdpbnMgZm9yIGV4YW1wbGUgdG8gbWFrZVxcbiAgLy8gaXQgY29tcGF0aWJsZSB3aXRoIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgRE9NIGZ1bGx5LlxcbiAgemVwdG8uZnJhZ21lbnQgPSBmdW5jdGlvbihodG1sLCBuYW1lLCBwcm9wZXJ0aWVzKSB7XFxuICAgIHZhciBkb20sIG5vZGVzLCBjb250YWluZXJcXG5cXG4gICAgLy8gQSBzcGVjaWFsIGNhc2Ugb3B0aW1pemF0aW9uIGZvciBhIHNpbmdsZSB0YWdcXG4gICAgaWYgKHNpbmdsZVRhZ1JFLnRlc3QoaHRtbCkpIGRvbSA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChSZWdFeHAuJDEpKVxcblxcbiAgICBpZiAoIWRvbSkge1xcbiAgICAgIGlmIChodG1sLnJlcGxhY2UpIGh0bWwgPSBodG1sLnJlcGxhY2UodGFnRXhwYW5kZXJSRSwgXFxcIjwkMT48LyQyPlxcXCIpXFxuICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgbmFtZSA9IGZyYWdtZW50UkUudGVzdChodG1sKSAmJiBSZWdFeHAuJDFcXG4gICAgICBpZiAoIShuYW1lIGluIGNvbnRhaW5lcnMpKSBuYW1lID0gJyonXFxuXFxuICAgICAgY29udGFpbmVyID0gY29udGFpbmVyc1tuYW1lXVxcbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJyArIGh0bWxcXG4gICAgICBkb20gPSAkLmVhY2goc2xpY2UuY2FsbChjb250YWluZXIuY2hpbGROb2RlcyksIGZ1bmN0aW9uKCl7XFxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcylcXG4gICAgICB9KVxcbiAgICB9XFxuXFxuICAgIGlmIChpc1BsYWluT2JqZWN0KHByb3BlcnRpZXMpKSB7XFxuICAgICAgbm9kZXMgPSAkKGRvbSlcXG4gICAgICAkLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgICAgaWYgKG1ldGhvZEF0dHJpYnV0ZXMuaW5kZXhPZihrZXkpID4gLTEpIG5vZGVzW2tleV0odmFsdWUpXFxuICAgICAgICBlbHNlIG5vZGVzLmF0dHIoa2V5LCB2YWx1ZSlcXG4gICAgICB9KVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBkb21cXG4gIH1cXG5cXG4gIC8vIGAkLnplcHRvLlpgIHN3YXBzIG91dCB0aGUgcHJvdG90eXBlIG9mIHRoZSBnaXZlbiBgZG9tYCBhcnJheVxcbiAgLy8gb2Ygbm9kZXMgd2l0aCBgJC5mbmAgYW5kIHRodXMgc3VwcGx5aW5nIGFsbCB0aGUgWmVwdG8gZnVuY3Rpb25zXFxuICAvLyB0byB0aGUgYXJyYXkuIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGluIHBsdWdpbnMuXFxuICB6ZXB0by5aID0gZnVuY3Rpb24oZG9tLCBzZWxlY3Rvcikge1xcbiAgICByZXR1cm4gbmV3IFooZG9tLCBzZWxlY3RvcilcXG4gIH1cXG5cXG4gIC8vIGAkLnplcHRvLmlzWmAgc2hvdWxkIHJldHVybiBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhIFplcHRvXFxuICAvLyBjb2xsZWN0aW9uLiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBwbHVnaW5zLlxcbiAgemVwdG8uaXNaID0gZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB6ZXB0by5aXFxuICB9XFxuXFxuICAvLyBgJC56ZXB0by5pbml0YCBpcyBaZXB0bydzIGNvdW50ZXJwYXJ0IHRvIGpRdWVyeSdzIGAkLmZuLmluaXRgIGFuZFxcbiAgLy8gdGFrZXMgYSBDU1Mgc2VsZWN0b3IgYW5kIGFuIG9wdGlvbmFsIGNvbnRleHQgKGFuZCBoYW5kbGVzIHZhcmlvdXNcXG4gIC8vIHNwZWNpYWwgY2FzZXMpLlxcbiAgLy8gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucy5cXG4gIHplcHRvLmluaXQgPSBmdW5jdGlvbihzZWxlY3RvciwgY29udGV4dCkge1xcbiAgICB2YXIgZG9tXFxuICAgIC8vIElmIG5vdGhpbmcgZ2l2ZW4sIHJldHVybiBhbiBlbXB0eSBaZXB0byBjb2xsZWN0aW9uXFxuICAgIGlmICghc2VsZWN0b3IpIHJldHVybiB6ZXB0by5aKClcXG4gICAgLy8gT3B0aW1pemUgZm9yIHN0cmluZyBzZWxlY3RvcnNcXG4gICAgZWxzZSBpZiAodHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnKSB7XFxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci50cmltKClcXG4gICAgICAvLyBJZiBpdCdzIGEgaHRtbCBmcmFnbWVudCwgY3JlYXRlIG5vZGVzIGZyb20gaXRcXG4gICAgICAvLyBOb3RlOiBJbiBib3RoIENocm9tZSAyMSBhbmQgRmlyZWZveCAxNSwgRE9NIGVycm9yIDEyXFxuICAgICAgLy8gaXMgdGhyb3duIGlmIHRoZSBmcmFnbWVudCBkb2Vzbid0IGJlZ2luIHdpdGggPFxcbiAgICAgIGlmIChzZWxlY3RvclswXSA9PSAnPCcgJiYgZnJhZ21lbnRSRS50ZXN0KHNlbGVjdG9yKSlcXG4gICAgICAgIGRvbSA9IHplcHRvLmZyYWdtZW50KHNlbGVjdG9yLCBSZWdFeHAuJDEsIGNvbnRleHQpLCBzZWxlY3RvciA9IG51bGxcXG4gICAgICAvLyBJZiB0aGVyZSdzIGEgY29udGV4dCwgY3JlYXRlIGEgY29sbGVjdGlvbiBvbiB0aGF0IGNvbnRleHQgZmlyc3QsIGFuZCBzZWxlY3RcXG4gICAgICAvLyBub2RlcyBmcm9tIHRoZXJlXFxuICAgICAgZWxzZSBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gJChjb250ZXh0KS5maW5kKHNlbGVjdG9yKVxcbiAgICAgIC8vIElmIGl0J3MgYSBDU1Mgc2VsZWN0b3IsIHVzZSBpdCB0byBzZWxlY3Qgbm9kZXMuXFxuICAgICAgZWxzZSBkb20gPSB6ZXB0by5xc2EoZG9jdW1lbnQsIHNlbGVjdG9yKVxcbiAgICB9XFxuICAgIC8vIElmIGEgZnVuY3Rpb24gaXMgZ2l2ZW4sIGNhbGwgaXQgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XFxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpKSByZXR1cm4gJChkb2N1bWVudCkucmVhZHkoc2VsZWN0b3IpXFxuICAgIC8vIElmIGEgWmVwdG8gY29sbGVjdGlvbiBpcyBnaXZlbiwganVzdCByZXR1cm4gaXRcXG4gICAgZWxzZSBpZiAoemVwdG8uaXNaKHNlbGVjdG9yKSkgcmV0dXJuIHNlbGVjdG9yXFxuICAgIGVsc2Uge1xcbiAgICAgIC8vIG5vcm1hbGl6ZSBhcnJheSBpZiBhbiBhcnJheSBvZiBub2RlcyBpcyBnaXZlblxcbiAgICAgIGlmIChpc0FycmF5KHNlbGVjdG9yKSkgZG9tID0gY29tcGFjdChzZWxlY3RvcilcXG4gICAgICAvLyBXcmFwIERPTSBub2Rlcy5cXG4gICAgICBlbHNlIGlmIChpc09iamVjdChzZWxlY3RvcikpXFxuICAgICAgICBkb20gPSBbc2VsZWN0b3JdLCBzZWxlY3RvciA9IG51bGxcXG4gICAgICAvLyBJZiBpdCdzIGEgaHRtbCBmcmFnbWVudCwgY3JlYXRlIG5vZGVzIGZyb20gaXRcXG4gICAgICBlbHNlIGlmIChmcmFnbWVudFJFLnRlc3Qoc2VsZWN0b3IpKVxcbiAgICAgICAgZG9tID0gemVwdG8uZnJhZ21lbnQoc2VsZWN0b3IudHJpbSgpLCBSZWdFeHAuJDEsIGNvbnRleHQpLCBzZWxlY3RvciA9IG51bGxcXG4gICAgICAvLyBJZiB0aGVyZSdzIGEgY29udGV4dCwgY3JlYXRlIGEgY29sbGVjdGlvbiBvbiB0aGF0IGNvbnRleHQgZmlyc3QsIGFuZCBzZWxlY3RcXG4gICAgICAvLyBub2RlcyBmcm9tIHRoZXJlXFxuICAgICAgZWxzZSBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gJChjb250ZXh0KS5maW5kKHNlbGVjdG9yKVxcbiAgICAgIC8vIEFuZCBsYXN0IGJ1dCBubyBsZWFzdCwgaWYgaXQncyBhIENTUyBzZWxlY3RvciwgdXNlIGl0IHRvIHNlbGVjdCBub2Rlcy5cXG4gICAgICBlbHNlIGRvbSA9IHplcHRvLnFzYShkb2N1bWVudCwgc2VsZWN0b3IpXFxuICAgIH1cXG4gICAgLy8gY3JlYXRlIGEgbmV3IFplcHRvIGNvbGxlY3Rpb24gZnJvbSB0aGUgbm9kZXMgZm91bmRcXG4gICAgcmV0dXJuIHplcHRvLlooZG9tLCBzZWxlY3RvcilcXG4gIH1cXG5cXG4gIC8vIGAkYCB3aWxsIGJlIHRoZSBiYXNlIGBaZXB0b2Agb2JqZWN0LiBXaGVuIGNhbGxpbmcgdGhpc1xcbiAgLy8gZnVuY3Rpb24ganVzdCBjYWxsIGAkLnplcHRvLmluaXQsIHdoaWNoIG1ha2VzIHRoZSBpbXBsZW1lbnRhdGlvblxcbiAgLy8gZGV0YWlscyBvZiBzZWxlY3Rpbmcgbm9kZXMgYW5kIGNyZWF0aW5nIFplcHRvIGNvbGxlY3Rpb25zXFxuICAvLyBwYXRjaGFibGUgaW4gcGx1Z2lucy5cXG4gICQgPSBmdW5jdGlvbihzZWxlY3RvciwgY29udGV4dCl7XFxuICAgIHJldHVybiB6ZXB0by5pbml0KHNlbGVjdG9yLCBjb250ZXh0KVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlLCBkZWVwKSB7XFxuICAgIGZvciAoa2V5IGluIHNvdXJjZSlcXG4gICAgICBpZiAoZGVlcCAmJiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgfHwgaXNBcnJheShzb3VyY2Vba2V5XSkpKSB7XFxuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgJiYgIWlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pKVxcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9XFxuICAgICAgICBpZiAoaXNBcnJheShzb3VyY2Vba2V5XSkgJiYgIWlzQXJyYXkodGFyZ2V0W2tleV0pKVxcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IFtdXFxuICAgICAgICBleHRlbmQodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBkZWVwKVxcbiAgICAgIH1cXG4gICAgICBlbHNlIGlmIChzb3VyY2Vba2V5XSAhPT0gdW5kZWZpbmVkKSB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXFxuICB9XFxuXFxuICAvLyBDb3B5IGFsbCBidXQgdW5kZWZpbmVkIHByb3BlcnRpZXMgZnJvbSBvbmUgb3IgbW9yZVxcbiAgLy8gb2JqZWN0cyB0byB0aGUgYHRhcmdldGAgb2JqZWN0LlxcbiAgJC5leHRlbmQgPSBmdW5jdGlvbih0YXJnZXQpe1xcbiAgICB2YXIgZGVlcCwgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PSAnYm9vbGVhbicpIHtcXG4gICAgICBkZWVwID0gdGFyZ2V0XFxuICAgICAgdGFyZ2V0ID0gYXJncy5zaGlmdCgpXFxuICAgIH1cXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKGFyZyl7IGV4dGVuZCh0YXJnZXQsIGFyZywgZGVlcCkgfSlcXG4gICAgcmV0dXJuIHRhcmdldFxcbiAgfVxcblxcbiAgLy8gYCQuemVwdG8ucXNhYCBpcyBaZXB0bydzIENTUyBzZWxlY3RvciBpbXBsZW1lbnRhdGlvbiB3aGljaFxcbiAgLy8gdXNlcyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbGAgYW5kIG9wdGltaXplcyBmb3Igc29tZSBzcGVjaWFsIGNhc2VzLCBsaWtlIGAjaWRgLlxcbiAgLy8gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucy5cXG4gIHplcHRvLnFzYSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHNlbGVjdG9yKXtcXG4gICAgdmFyIGZvdW5kLFxcbiAgICAgICAgbWF5YmVJRCA9IHNlbGVjdG9yWzBdID09ICcjJyxcXG4gICAgICAgIG1heWJlQ2xhc3MgPSAhbWF5YmVJRCAmJiBzZWxlY3RvclswXSA9PSAnLicsXFxuICAgICAgICBuYW1lT25seSA9IG1heWJlSUQgfHwgbWF5YmVDbGFzcyA/IHNlbGVjdG9yLnNsaWNlKDEpIDogc2VsZWN0b3IsIC8vIEVuc3VyZSB0aGF0IGEgMSBjaGFyIHRhZyBuYW1lIHN0aWxsIGdldHMgY2hlY2tlZFxcbiAgICAgICAgaXNTaW1wbGUgPSBzaW1wbGVTZWxlY3RvclJFLnRlc3QobmFtZU9ubHkpXFxuICAgIHJldHVybiAoZWxlbWVudC5nZXRFbGVtZW50QnlJZCAmJiBpc1NpbXBsZSAmJiBtYXliZUlEKSA/IC8vIFNhZmFyaSBEb2N1bWVudEZyYWdtZW50IGRvZXNuJ3QgaGF2ZSBnZXRFbGVtZW50QnlJZFxcbiAgICAgICggKGZvdW5kID0gZWxlbWVudC5nZXRFbGVtZW50QnlJZChuYW1lT25seSkpID8gW2ZvdW5kXSA6IFtdICkgOlxcbiAgICAgIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxICYmIGVsZW1lbnQubm9kZVR5cGUgIT09IDkgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gMTEpID8gW10gOlxcbiAgICAgIHNsaWNlLmNhbGwoXFxuICAgICAgICBpc1NpbXBsZSAmJiAhbWF5YmVJRCAmJiBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPyAvLyBEb2N1bWVudEZyYWdtZW50IGRvZXNuJ3QgaGF2ZSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lL1RhZ05hbWVcXG4gICAgICAgICAgbWF5YmVDbGFzcyA/IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShuYW1lT25seSkgOiAvLyBJZiBpdCdzIHNpbXBsZSwgaXQgY291bGQgYmUgYSBjbGFzc1xcbiAgICAgICAgICBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbGVjdG9yKSA6IC8vIE9yIGEgdGFnXFxuICAgICAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgLy8gT3IgaXQncyBub3Qgc2ltcGxlLCBhbmQgd2UgbmVlZCB0byBxdWVyeSBhbGxcXG4gICAgICApXFxuICB9XFxuXFxuICBmdW5jdGlvbiBmaWx0ZXJlZChub2Rlcywgc2VsZWN0b3IpIHtcXG4gICAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyAkKG5vZGVzKSA6ICQobm9kZXMpLmZpbHRlcihzZWxlY3RvcilcXG4gIH1cXG5cXG4gICQuY29udGFpbnMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMgP1xcbiAgICBmdW5jdGlvbihwYXJlbnQsIG5vZGUpIHtcXG4gICAgICByZXR1cm4gcGFyZW50ICE9PSBub2RlICYmIHBhcmVudC5jb250YWlucyhub2RlKVxcbiAgICB9IDpcXG4gICAgZnVuY3Rpb24ocGFyZW50LCBub2RlKSB7XFxuICAgICAgd2hpbGUgKG5vZGUgJiYgKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKVxcbiAgICAgICAgaWYgKG5vZGUgPT09IHBhcmVudCkgcmV0dXJuIHRydWVcXG4gICAgICByZXR1cm4gZmFsc2VcXG4gICAgfVxcblxcbiAgZnVuY3Rpb24gZnVuY0FyZyhjb250ZXh0LCBhcmcsIGlkeCwgcGF5bG9hZCkge1xcbiAgICByZXR1cm4gaXNGdW5jdGlvbihhcmcpID8gYXJnLmNhbGwoY29udGV4dCwgaWR4LCBwYXlsb2FkKSA6IGFyZ1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XFxuICAgIHZhbHVlID09IG51bGwgPyBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKSA6IG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKVxcbiAgfVxcblxcbiAgLy8gYWNjZXNzIGNsYXNzTmFtZSBwcm9wZXJ0eSB3aGlsZSByZXNwZWN0aW5nIFNWR0FuaW1hdGVkU3RyaW5nXFxuICBmdW5jdGlvbiBjbGFzc05hbWUobm9kZSwgdmFsdWUpe1xcbiAgICB2YXIga2xhc3MgPSBub2RlLmNsYXNzTmFtZSB8fCAnJyxcXG4gICAgICAgIHN2ZyAgID0ga2xhc3MgJiYga2xhc3MuYmFzZVZhbCAhPT0gdW5kZWZpbmVkXFxuXFxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gc3ZnID8ga2xhc3MuYmFzZVZhbCA6IGtsYXNzXFxuICAgIHN2ZyA/IChrbGFzcy5iYXNlVmFsID0gdmFsdWUpIDogKG5vZGUuY2xhc3NOYW1lID0gdmFsdWUpXFxuICB9XFxuXFxuICAvLyBcXFwidHJ1ZVxcXCIgID0+IHRydWVcXG4gIC8vIFxcXCJmYWxzZVxcXCIgPT4gZmFsc2VcXG4gIC8vIFxcXCJudWxsXFxcIiAgPT4gbnVsbFxcbiAgLy8gXFxcIjQyXFxcIiAgICA9PiA0MlxcbiAgLy8gXFxcIjQyLjVcXFwiICA9PiA0Mi41XFxuICAvLyBcXFwiMDhcXFwiICAgID0+IFxcXCIwOFxcXCJcXG4gIC8vIEpTT04gICAgPT4gcGFyc2UgaWYgdmFsaWRcXG4gIC8vIFN0cmluZyAgPT4gc2VsZlxcbiAgZnVuY3Rpb24gZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSkge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiB2YWx1ZSA/XFxuICAgICAgICB2YWx1ZSA9PSBcXFwidHJ1ZVxcXCIgfHxcXG4gICAgICAgICggdmFsdWUgPT0gXFxcImZhbHNlXFxcIiA/IGZhbHNlIDpcXG4gICAgICAgICAgdmFsdWUgPT0gXFxcIm51bGxcXFwiID8gbnVsbCA6XFxuICAgICAgICAgICt2YWx1ZSArIFxcXCJcXFwiID09IHZhbHVlID8gK3ZhbHVlIDpcXG4gICAgICAgICAgL15bXFxcXFtcXFxce10vLnRlc3QodmFsdWUpID8gJC5wYXJzZUpTT04odmFsdWUpIDpcXG4gICAgICAgICAgdmFsdWUgKVxcbiAgICAgICAgOiB2YWx1ZVxcbiAgICB9IGNhdGNoKGUpIHtcXG4gICAgICByZXR1cm4gdmFsdWVcXG4gICAgfVxcbiAgfVxcblxcbiAgJC50eXBlID0gdHlwZVxcbiAgJC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvblxcbiAgJC5pc1dpbmRvdyA9IGlzV2luZG93XFxuICAkLmlzQXJyYXkgPSBpc0FycmF5XFxuICAkLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0XFxuXFxuICAkLmlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcXG4gICAgdmFyIG5hbWVcXG4gICAgZm9yIChuYW1lIGluIG9iaikgcmV0dXJuIGZhbHNlXFxuICAgIHJldHVybiB0cnVlXFxuICB9XFxuXFxuICAkLmlzTnVtZXJpYyA9IGZ1bmN0aW9uKHZhbCkge1xcbiAgICB2YXIgbnVtID0gTnVtYmVyKHZhbCksIHR5cGUgPSB0eXBlb2YgdmFsXFxuICAgIHJldHVybiB2YWwgIT0gbnVsbCAmJiB0eXBlICE9ICdib29sZWFuJyAmJlxcbiAgICAgICh0eXBlICE9ICdzdHJpbmcnIHx8IHZhbC5sZW5ndGgpICYmXFxuICAgICAgIWlzTmFOKG51bSkgJiYgaXNGaW5pdGUobnVtKSB8fCBmYWxzZVxcbiAgfVxcblxcbiAgJC5pbkFycmF5ID0gZnVuY3Rpb24oZWxlbSwgYXJyYXksIGkpe1xcbiAgICByZXR1cm4gZW1wdHlBcnJheS5pbmRleE9mLmNhbGwoYXJyYXksIGVsZW0sIGkpXFxuICB9XFxuXFxuICAkLmNhbWVsQ2FzZSA9IGNhbWVsaXplXFxuICAkLnRyaW0gPSBmdW5jdGlvbihzdHIpIHtcXG4gICAgcmV0dXJuIHN0ciA9PSBudWxsID8gXFxcIlxcXCIgOiBTdHJpbmcucHJvdG90eXBlLnRyaW0uY2FsbChzdHIpXFxuICB9XFxuXFxuICAvLyBwbHVnaW4gY29tcGF0aWJpbGl0eVxcbiAgJC51dWlkID0gMFxcbiAgJC5zdXBwb3J0ID0geyB9XFxuICAkLmV4cHIgPSB7IH1cXG4gICQubm9vcCA9IGZ1bmN0aW9uKCkge31cXG5cXG4gICQubWFwID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKXtcXG4gICAgdmFyIHZhbHVlLCB2YWx1ZXMgPSBbXSwgaSwga2V5XFxuICAgIGlmIChsaWtlQXJyYXkoZWxlbWVudHMpKVxcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtZW50c1tpXSwgaSlcXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZXMucHVzaCh2YWx1ZSlcXG4gICAgICB9XFxuICAgIGVsc2VcXG4gICAgICBmb3IgKGtleSBpbiBlbGVtZW50cykge1xcbiAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtZW50c1trZXldLCBrZXkpXFxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkgdmFsdWVzLnB1c2godmFsdWUpXFxuICAgICAgfVxcbiAgICByZXR1cm4gZmxhdHRlbih2YWx1ZXMpXFxuICB9XFxuXFxuICAkLmVhY2ggPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spe1xcbiAgICB2YXIgaSwga2V5XFxuICAgIGlmIChsaWtlQXJyYXkoZWxlbWVudHMpKSB7XFxuICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKVxcbiAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwoZWxlbWVudHNbaV0sIGksIGVsZW1lbnRzW2ldKSA9PT0gZmFsc2UpIHJldHVybiBlbGVtZW50c1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZvciAoa2V5IGluIGVsZW1lbnRzKVxcbiAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwoZWxlbWVudHNba2V5XSwga2V5LCBlbGVtZW50c1trZXldKSA9PT0gZmFsc2UpIHJldHVybiBlbGVtZW50c1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBlbGVtZW50c1xcbiAgfVxcblxcbiAgJC5ncmVwID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKXtcXG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKGVsZW1lbnRzLCBjYWxsYmFjaylcXG4gIH1cXG5cXG4gIGlmICh3aW5kb3cuSlNPTikgJC5wYXJzZUpTT04gPSBKU09OLnBhcnNlXFxuXFxuICAvLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcXG4gICQuZWFjaChcXFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZnVuY3Rpb24oaSwgbmFtZSkge1xcbiAgICBjbGFzczJ0eXBlWyBcXFwiW29iamVjdCBcXFwiICsgbmFtZSArIFxcXCJdXFxcIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpXFxuICB9KVxcblxcbiAgLy8gRGVmaW5lIG1ldGhvZHMgdGhhdCB3aWxsIGJlIGF2YWlsYWJsZSBvbiBhbGxcXG4gIC8vIFplcHRvIGNvbGxlY3Rpb25zXFxuICAkLmZuID0ge1xcbiAgICBjb25zdHJ1Y3RvcjogemVwdG8uWixcXG4gICAgbGVuZ3RoOiAwLFxcblxcbiAgICAvLyBCZWNhdXNlIGEgY29sbGVjdGlvbiBhY3RzIGxpa2UgYW4gYXJyYXlcXG4gICAgLy8gY29weSBvdmVyIHRoZXNlIHVzZWZ1bCBhcnJheSBmdW5jdGlvbnMuXFxuICAgIGZvckVhY2g6IGVtcHR5QXJyYXkuZm9yRWFjaCxcXG4gICAgcmVkdWNlOiBlbXB0eUFycmF5LnJlZHVjZSxcXG4gICAgcHVzaDogZW1wdHlBcnJheS5wdXNoLFxcbiAgICBzb3J0OiBlbXB0eUFycmF5LnNvcnQsXFxuICAgIHNwbGljZTogZW1wdHlBcnJheS5zcGxpY2UsXFxuICAgIGluZGV4T2Y6IGVtcHR5QXJyYXkuaW5kZXhPZixcXG4gICAgY29uY2F0OiBmdW5jdGlvbigpe1xcbiAgICAgIHZhciBpLCB2YWx1ZSwgYXJncyA9IFtdXFxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFsdWUgPSBhcmd1bWVudHNbaV1cXG4gICAgICAgIGFyZ3NbaV0gPSB6ZXB0by5pc1oodmFsdWUpID8gdmFsdWUudG9BcnJheSgpIDogdmFsdWVcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseSh6ZXB0by5pc1oodGhpcykgPyB0aGlzLnRvQXJyYXkoKSA6IHRoaXMsIGFyZ3MpXFxuICAgIH0sXFxuXFxuICAgIC8vIGBtYXBgIGFuZCBgc2xpY2VgIGluIHRoZSBqUXVlcnkgQVBJIHdvcmsgZGlmZmVyZW50bHlcXG4gICAgLy8gZnJvbSB0aGVpciBhcnJheSBjb3VudGVycGFydHNcXG4gICAgbWFwOiBmdW5jdGlvbihmbil7XFxuICAgICAgcmV0dXJuICQoJC5tYXAodGhpcywgZnVuY3Rpb24oZWwsIGkpeyByZXR1cm4gZm4uY2FsbChlbCwgaSwgZWwpIH0pKVxcbiAgICB9LFxcbiAgICBzbGljZTogZnVuY3Rpb24oKXtcXG4gICAgICByZXR1cm4gJChzbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKVxcbiAgICB9LFxcblxcbiAgICByZWFkeTogZnVuY3Rpb24oY2FsbGJhY2spe1xcbiAgICAgIC8vIG5lZWQgdG8gY2hlY2sgaWYgZG9jdW1lbnQuYm9keSBleGlzdHMgZm9yIElFIGFzIHRoYXQgYnJvd3NlciByZXBvcnRzXFxuICAgICAgLy8gZG9jdW1lbnQgcmVhZHkgd2hlbiBpdCBoYXNuJ3QgeWV0IGNyZWF0ZWQgdGhlIGJvZHkgZWxlbWVudFxcbiAgICAgIGlmIChyZWFkeVJFLnRlc3QoZG9jdW1lbnQucmVhZHlTdGF0ZSkgJiYgZG9jdW1lbnQuYm9keSkgY2FsbGJhY2soJClcXG4gICAgICBlbHNlIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpeyBjYWxsYmFjaygkKSB9LCBmYWxzZSlcXG4gICAgICByZXR1cm4gdGhpc1xcbiAgICB9LFxcbiAgICBnZXQ6IGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgcmV0dXJuIGlkeCA9PT0gdW5kZWZpbmVkID8gc2xpY2UuY2FsbCh0aGlzKSA6IHRoaXNbaWR4ID49IDAgPyBpZHggOiBpZHggKyB0aGlzLmxlbmd0aF1cXG4gICAgfSxcXG4gICAgdG9BcnJheTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZ2V0KCkgfSxcXG4gICAgc2l6ZTogZnVuY3Rpb24oKXtcXG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGhcXG4gICAgfSxcXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpe1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcXG4gICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUgIT0gbnVsbClcXG4gICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpXFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgZWFjaDogZnVuY3Rpb24oY2FsbGJhY2spe1xcbiAgICAgIGVtcHR5QXJyYXkuZXZlcnkuY2FsbCh0aGlzLCBmdW5jdGlvbihlbCwgaWR4KXtcXG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKGVsLCBpZHgsIGVsKSAhPT0gZmFsc2VcXG4gICAgICB9KVxcbiAgICAgIHJldHVybiB0aGlzXFxuICAgIH0sXFxuICAgIGZpbHRlcjogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkgcmV0dXJuIHRoaXMubm90KHRoaXMubm90KHNlbGVjdG9yKSlcXG4gICAgICByZXR1cm4gJChmaWx0ZXIuY2FsbCh0aGlzLCBmdW5jdGlvbihlbGVtZW50KXtcXG4gICAgICAgIHJldHVybiB6ZXB0by5tYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKVxcbiAgICAgIH0pKVxcbiAgICB9LFxcbiAgICBhZGQ6IGZ1bmN0aW9uKHNlbGVjdG9yLGNvbnRleHQpe1xcbiAgICAgIHJldHVybiAkKHVuaXEodGhpcy5jb25jYXQoJChzZWxlY3Rvcixjb250ZXh0KSkpKVxcbiAgICB9LFxcbiAgICBpczogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDAgJiYgemVwdG8ubWF0Y2hlcyh0aGlzWzBdLCBzZWxlY3RvcilcXG4gICAgfSxcXG4gICAgbm90OiBmdW5jdGlvbihzZWxlY3Rvcil7XFxuICAgICAgdmFyIG5vZGVzPVtdXFxuICAgICAgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpICYmIHNlbGVjdG9yLmNhbGwgIT09IHVuZGVmaW5lZClcXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgICBpZiAoIXNlbGVjdG9yLmNhbGwodGhpcyxpZHgpKSBub2Rlcy5wdXNoKHRoaXMpXFxuICAgICAgICB9KVxcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgdmFyIGV4Y2x1ZGVzID0gdHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnID8gdGhpcy5maWx0ZXIoc2VsZWN0b3IpIDpcXG4gICAgICAgICAgKGxpa2VBcnJheShzZWxlY3RvcikgJiYgaXNGdW5jdGlvbihzZWxlY3Rvci5pdGVtKSkgPyBzbGljZS5jYWxsKHNlbGVjdG9yKSA6ICQoc2VsZWN0b3IpXFxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oZWwpe1xcbiAgICAgICAgICBpZiAoZXhjbHVkZXMuaW5kZXhPZihlbCkgPCAwKSBub2Rlcy5wdXNoKGVsKVxcbiAgICAgICAgfSlcXG4gICAgICB9XFxuICAgICAgcmV0dXJuICQobm9kZXMpXFxuICAgIH0sXFxuICAgIGhhczogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpe1xcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHNlbGVjdG9yKSA/XFxuICAgICAgICAgICQuY29udGFpbnModGhpcywgc2VsZWN0b3IpIDpcXG4gICAgICAgICAgJCh0aGlzKS5maW5kKHNlbGVjdG9yKS5zaXplKClcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICBlcTogZnVuY3Rpb24oaWR4KXtcXG4gICAgICByZXR1cm4gaWR4ID09PSAtMSA/IHRoaXMuc2xpY2UoaWR4KSA6IHRoaXMuc2xpY2UoaWR4LCArIGlkeCArIDEpXFxuICAgIH0sXFxuICAgIGZpcnN0OiBmdW5jdGlvbigpe1xcbiAgICAgIHZhciBlbCA9IHRoaXNbMF1cXG4gICAgICByZXR1cm4gZWwgJiYgIWlzT2JqZWN0KGVsKSA/IGVsIDogJChlbClcXG4gICAgfSxcXG4gICAgbGFzdDogZnVuY3Rpb24oKXtcXG4gICAgICB2YXIgZWwgPSB0aGlzW3RoaXMubGVuZ3RoIC0gMV1cXG4gICAgICByZXR1cm4gZWwgJiYgIWlzT2JqZWN0KGVsKSA/IGVsIDogJChlbClcXG4gICAgfSxcXG4gICAgZmluZDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHZhciByZXN1bHQsICR0aGlzID0gdGhpc1xcbiAgICAgIGlmICghc2VsZWN0b3IpIHJlc3VsdCA9ICQoKVxcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RvciA9PSAnb2JqZWN0JylcXG4gICAgICAgIHJlc3VsdCA9ICQoc2VsZWN0b3IpLmZpbHRlcihmdW5jdGlvbigpe1xcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXNcXG4gICAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXkuc29tZS5jYWxsKCR0aGlzLCBmdW5jdGlvbihwYXJlbnQpe1xcbiAgICAgICAgICAgIHJldHVybiAkLmNvbnRhaW5zKHBhcmVudCwgbm9kZSlcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH0pXFxuICAgICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPT0gMSkgcmVzdWx0ID0gJCh6ZXB0by5xc2EodGhpc1swXSwgc2VsZWN0b3IpKVxcbiAgICAgIGVsc2UgcmVzdWx0ID0gdGhpcy5tYXAoZnVuY3Rpb24oKXsgcmV0dXJuIHplcHRvLnFzYSh0aGlzLCBzZWxlY3RvcikgfSlcXG4gICAgICByZXR1cm4gcmVzdWx0XFxuICAgIH0sXFxuICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KXtcXG4gICAgICB2YXIgbm9kZXMgPSBbXSwgY29sbGVjdGlvbiA9IHR5cGVvZiBzZWxlY3RvciA9PSAnb2JqZWN0JyAmJiAkKHNlbGVjdG9yKVxcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihfLCBub2RlKXtcXG4gICAgICAgIHdoaWxlIChub2RlICYmICEoY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24uaW5kZXhPZihub2RlKSA+PSAwIDogemVwdG8ubWF0Y2hlcyhub2RlLCBzZWxlY3RvcikpKVxcbiAgICAgICAgICBub2RlID0gbm9kZSAhPT0gY29udGV4dCAmJiAhaXNEb2N1bWVudChub2RlKSAmJiBub2RlLnBhcmVudE5vZGVcXG4gICAgICAgIGlmIChub2RlICYmIG5vZGVzLmluZGV4T2Yobm9kZSkgPCAwKSBub2Rlcy5wdXNoKG5vZGUpXFxuICAgICAgfSlcXG4gICAgICByZXR1cm4gJChub2RlcylcXG4gICAgfSxcXG4gICAgcGFyZW50czogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHZhciBhbmNlc3RvcnMgPSBbXSwgbm9kZXMgPSB0aGlzXFxuICAgICAgd2hpbGUgKG5vZGVzLmxlbmd0aCA+IDApXFxuICAgICAgICBub2RlcyA9ICQubWFwKG5vZGVzLCBmdW5jdGlvbihub2RlKXtcXG4gICAgICAgICAgaWYgKChub2RlID0gbm9kZS5wYXJlbnROb2RlKSAmJiAhaXNEb2N1bWVudChub2RlKSAmJiBhbmNlc3RvcnMuaW5kZXhPZihub2RlKSA8IDApIHtcXG4gICAgICAgICAgICBhbmNlc3RvcnMucHVzaChub2RlKVxcbiAgICAgICAgICAgIHJldHVybiBub2RlXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pXFxuICAgICAgcmV0dXJuIGZpbHRlcmVkKGFuY2VzdG9ycywgc2VsZWN0b3IpXFxuICAgIH0sXFxuICAgIHBhcmVudDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHJldHVybiBmaWx0ZXJlZCh1bmlxKHRoaXMucGx1Y2soJ3BhcmVudE5vZGUnKSksIHNlbGVjdG9yKVxcbiAgICB9LFxcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHJldHVybiBmaWx0ZXJlZCh0aGlzLm1hcChmdW5jdGlvbigpeyByZXR1cm4gY2hpbGRyZW4odGhpcykgfSksIHNlbGVjdG9yKVxcbiAgICB9LFxcbiAgICBjb250ZW50czogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb250ZW50RG9jdW1lbnQgfHwgc2xpY2UuY2FsbCh0aGlzLmNoaWxkTm9kZXMpIH0pXFxuICAgIH0sXFxuICAgIHNpYmxpbmdzOiBmdW5jdGlvbihzZWxlY3Rvcil7XFxuICAgICAgcmV0dXJuIGZpbHRlcmVkKHRoaXMubWFwKGZ1bmN0aW9uKGksIGVsKXtcXG4gICAgICAgIHJldHVybiBmaWx0ZXIuY2FsbChjaGlsZHJlbihlbC5wYXJlbnROb2RlKSwgZnVuY3Rpb24oY2hpbGQpeyByZXR1cm4gY2hpbGQhPT1lbCB9KVxcbiAgICAgIH0pLCBzZWxlY3RvcilcXG4gICAgfSxcXG4gICAgZW1wdHk6IGZ1bmN0aW9uKCl7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLmlubmVySFRNTCA9ICcnIH0pXFxuICAgIH0sXFxuICAgIC8vIGBwbHVja2AgaXMgYm9ycm93ZWQgZnJvbSBQcm90b3R5cGUuanNcXG4gICAgcGx1Y2s6IGZ1bmN0aW9uKHByb3BlcnR5KXtcXG4gICAgICByZXR1cm4gJC5tYXAodGhpcywgZnVuY3Rpb24oZWwpeyByZXR1cm4gZWxbcHJvcGVydHldIH0pXFxuICAgIH0sXFxuICAgIHNob3c6IGZ1bmN0aW9uKCl7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xcbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID09IFxcXCJub25lXFxcIiAmJiAodGhpcy5zdHlsZS5kaXNwbGF5ID0gJycpXFxuICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLCAnJykuZ2V0UHJvcGVydHlWYWx1ZShcXFwiZGlzcGxheVxcXCIpID09IFxcXCJub25lXFxcIilcXG4gICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gZGVmYXVsdERpc3BsYXkodGhpcy5ub2RlTmFtZSlcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24obmV3Q29udGVudCl7XFxuICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlKG5ld0NvbnRlbnQpLnJlbW92ZSgpXFxuICAgIH0sXFxuICAgIHdyYXA6IGZ1bmN0aW9uKHN0cnVjdHVyZSl7XFxuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmN0aW9uKHN0cnVjdHVyZSlcXG4gICAgICBpZiAodGhpc1swXSAmJiAhZnVuYylcXG4gICAgICAgIHZhciBkb20gICA9ICQoc3RydWN0dXJlKS5nZXQoMCksXFxuICAgICAgICAgICAgY2xvbmUgPSBkb20ucGFyZW50Tm9kZSB8fCB0aGlzLmxlbmd0aCA+IDFcXG5cXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGluZGV4KXtcXG4gICAgICAgICQodGhpcykud3JhcEFsbChcXG4gICAgICAgICAgZnVuYyA/IHN0cnVjdHVyZS5jYWxsKHRoaXMsIGluZGV4KSA6XFxuICAgICAgICAgICAgY2xvbmUgPyBkb20uY2xvbmVOb2RlKHRydWUpIDogZG9tXFxuICAgICAgICApXFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgd3JhcEFsbDogZnVuY3Rpb24oc3RydWN0dXJlKXtcXG4gICAgICBpZiAodGhpc1swXSkge1xcbiAgICAgICAgJCh0aGlzWzBdKS5iZWZvcmUoc3RydWN0dXJlID0gJChzdHJ1Y3R1cmUpKVxcbiAgICAgICAgdmFyIGNoaWxkcmVuXFxuICAgICAgICAvLyBkcmlsbCBkb3duIHRvIHRoZSBpbm1vc3QgZWxlbWVudFxcbiAgICAgICAgd2hpbGUgKChjaGlsZHJlbiA9IHN0cnVjdHVyZS5jaGlsZHJlbigpKS5sZW5ndGgpIHN0cnVjdHVyZSA9IGNoaWxkcmVuLmZpcnN0KClcXG4gICAgICAgICQoc3RydWN0dXJlKS5hcHBlbmQodGhpcylcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRoaXNcXG4gICAgfSxcXG4gICAgd3JhcElubmVyOiBmdW5jdGlvbihzdHJ1Y3R1cmUpe1xcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jdGlvbihzdHJ1Y3R1cmUpXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpbmRleCl7XFxuICAgICAgICB2YXIgc2VsZiA9ICQodGhpcyksIGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpLFxcbiAgICAgICAgICAgIGRvbSAgPSBmdW5jID8gc3RydWN0dXJlLmNhbGwodGhpcywgaW5kZXgpIDogc3RydWN0dXJlXFxuICAgICAgICBjb250ZW50cy5sZW5ndGggPyBjb250ZW50cy53cmFwQWxsKGRvbSkgOiBzZWxmLmFwcGVuZChkb20pXFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgdW53cmFwOiBmdW5jdGlvbigpe1xcbiAgICAgIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpe1xcbiAgICAgICAgJCh0aGlzKS5yZXBsYWNlV2l0aCgkKHRoaXMpLmNoaWxkcmVuKCkpXFxuICAgICAgfSlcXG4gICAgICByZXR1cm4gdGhpc1xcbiAgICB9LFxcbiAgICBjbG9uZTogZnVuY3Rpb24oKXtcXG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuY2xvbmVOb2RlKHRydWUpIH0pXFxuICAgIH0sXFxuICAgIGhpZGU6IGZ1bmN0aW9uKCl7XFxuICAgICAgcmV0dXJuIHRoaXMuY3NzKFxcXCJkaXNwbGF5XFxcIiwgXFxcIm5vbmVcXFwiKVxcbiAgICB9LFxcbiAgICB0b2dnbGU6IGZ1bmN0aW9uKHNldHRpbmcpe1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcXG4gICAgICAgIHZhciBlbCA9ICQodGhpcylcXG4gICAgICAgIDsoc2V0dGluZyA9PT0gdW5kZWZpbmVkID8gZWwuY3NzKFxcXCJkaXNwbGF5XFxcIikgPT0gXFxcIm5vbmVcXFwiIDogc2V0dGluZykgPyBlbC5zaG93KCkgOiBlbC5oaWRlKClcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICBwcmV2OiBmdW5jdGlvbihzZWxlY3Rvcil7IHJldHVybiAkKHRoaXMucGx1Y2soJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnKSkuZmlsdGVyKHNlbGVjdG9yIHx8ICcqJykgfSxcXG4gICAgbmV4dDogZnVuY3Rpb24oc2VsZWN0b3IpeyByZXR1cm4gJCh0aGlzLnBsdWNrKCduZXh0RWxlbWVudFNpYmxpbmcnKSkuZmlsdGVyKHNlbGVjdG9yIHx8ICcqJykgfSxcXG4gICAgaHRtbDogZnVuY3Rpb24oaHRtbCl7XFxuICAgICAgcmV0dXJuIDAgaW4gYXJndW1lbnRzID9cXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgICB2YXIgb3JpZ2luSHRtbCA9IHRoaXMuaW5uZXJIVE1MXFxuICAgICAgICAgICQodGhpcykuZW1wdHkoKS5hcHBlbmQoIGZ1bmNBcmcodGhpcywgaHRtbCwgaWR4LCBvcmlnaW5IdG1sKSApXFxuICAgICAgICB9KSA6XFxuICAgICAgICAoMCBpbiB0aGlzID8gdGhpc1swXS5pbm5lckhUTUwgOiBudWxsKVxcbiAgICB9LFxcbiAgICB0ZXh0OiBmdW5jdGlvbih0ZXh0KXtcXG4gICAgICByZXR1cm4gMCBpbiBhcmd1bWVudHMgP1xcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICAgIHZhciBuZXdUZXh0ID0gZnVuY0FyZyh0aGlzLCB0ZXh0LCBpZHgsIHRoaXMudGV4dENvbnRlbnQpXFxuICAgICAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBuZXdUZXh0ID09IG51bGwgPyAnJyA6ICcnK25ld1RleHRcXG4gICAgICAgIH0pIDpcXG4gICAgICAgICgwIGluIHRoaXMgPyB0aGlzLnBsdWNrKCd0ZXh0Q29udGVudCcpLmpvaW4oXFxcIlxcXCIpIDogbnVsbClcXG4gICAgfSxcXG4gICAgYXR0cjogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xcbiAgICAgIHZhciByZXN1bHRcXG4gICAgICByZXR1cm4gKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnICYmICEoMSBpbiBhcmd1bWVudHMpKSA/XFxuICAgICAgICAoMCBpbiB0aGlzICYmIHRoaXNbMF0ubm9kZVR5cGUgPT0gMSAmJiAocmVzdWx0ID0gdGhpc1swXS5nZXRBdHRyaWJ1dGUobmFtZSkpICE9IG51bGwgPyByZXN1bHQgOiB1bmRlZmluZWQpIDpcXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuXFxuICAgICAgICAgIGlmIChpc09iamVjdChuYW1lKSkgZm9yIChrZXkgaW4gbmFtZSkgc2V0QXR0cmlidXRlKHRoaXMsIGtleSwgbmFtZVtrZXldKVxcbiAgICAgICAgICBlbHNlIHNldEF0dHJpYnV0ZSh0aGlzLCBuYW1lLCBmdW5jQXJnKHRoaXMsIHZhbHVlLCBpZHgsIHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpKSlcXG4gICAgICAgIH0pXFxuICAgIH0sXFxuICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKG5hbWUpe1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiBuYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xcbiAgICAgICAgc2V0QXR0cmlidXRlKHRoaXMsIGF0dHJpYnV0ZSlcXG4gICAgICB9LCB0aGlzKX0pXFxuICAgIH0sXFxuICAgIHByb3A6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKXtcXG4gICAgICBuYW1lID0gcHJvcE1hcFtuYW1lXSB8fCBuYW1lXFxuICAgICAgcmV0dXJuICgxIGluIGFyZ3VtZW50cykgP1xcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICAgIHRoaXNbbmFtZV0gPSBmdW5jQXJnKHRoaXMsIHZhbHVlLCBpZHgsIHRoaXNbbmFtZV0pXFxuICAgICAgICB9KSA6XFxuICAgICAgICAodGhpc1swXSAmJiB0aGlzWzBdW25hbWVdKVxcbiAgICB9LFxcbiAgICByZW1vdmVQcm9wOiBmdW5jdGlvbihuYW1lKXtcXG4gICAgICBuYW1lID0gcHJvcE1hcFtuYW1lXSB8fCBuYW1lXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpeyBkZWxldGUgdGhpc1tuYW1lXSB9KVxcbiAgICB9LFxcbiAgICBkYXRhOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSl7XFxuICAgICAgdmFyIGF0dHJOYW1lID0gJ2RhdGEtJyArIG5hbWUucmVwbGFjZShjYXBpdGFsUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXFxuXFxuICAgICAgdmFyIGRhdGEgPSAoMSBpbiBhcmd1bWVudHMpID9cXG4gICAgICAgIHRoaXMuYXR0cihhdHRyTmFtZSwgdmFsdWUpIDpcXG4gICAgICAgIHRoaXMuYXR0cihhdHRyTmFtZSlcXG5cXG4gICAgICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRlc2VyaWFsaXplVmFsdWUoZGF0YSkgOiB1bmRlZmluZWRcXG4gICAgfSxcXG4gICAgdmFsOiBmdW5jdGlvbih2YWx1ZSl7XFxuICAgICAgaWYgKDAgaW4gYXJndW1lbnRzKSB7XFxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgdmFsdWUgPSBcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgICB0aGlzLnZhbHVlID0gZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzLnZhbHVlKVxcbiAgICAgICAgfSlcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgKHRoaXNbMF0ubXVsdGlwbGUgP1xcbiAgICAgICAgICAgJCh0aGlzWzBdKS5maW5kKCdvcHRpb24nKS5maWx0ZXIoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuc2VsZWN0ZWQgfSkucGx1Y2soJ3ZhbHVlJykgOlxcbiAgICAgICAgICAgdGhpc1swXS52YWx1ZSlcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIG9mZnNldDogZnVuY3Rpb24oY29vcmRpbmF0ZXMpe1xcbiAgICAgIGlmIChjb29yZGluYXRlcykgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpbmRleCl7XFxuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxcbiAgICAgICAgICAgIGNvb3JkcyA9IGZ1bmNBcmcodGhpcywgY29vcmRpbmF0ZXMsIGluZGV4LCAkdGhpcy5vZmZzZXQoKSksXFxuICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gJHRoaXMub2Zmc2V0UGFyZW50KCkub2Zmc2V0KCksXFxuICAgICAgICAgICAgcHJvcHMgPSB7XFxuICAgICAgICAgICAgICB0b3A6ICBjb29yZHMudG9wICAtIHBhcmVudE9mZnNldC50b3AsXFxuICAgICAgICAgICAgICBsZWZ0OiBjb29yZHMubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCR0aGlzLmNzcygncG9zaXRpb24nKSA9PSAnc3RhdGljJykgcHJvcHNbJ3Bvc2l0aW9uJ10gPSAncmVsYXRpdmUnXFxuICAgICAgICAkdGhpcy5jc3MocHJvcHMpXFxuICAgICAgfSlcXG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm4gbnVsbFxcbiAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgIT09IHRoaXNbMF0gJiYgISQuY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzWzBdKSlcXG4gICAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiAwfVxcbiAgICAgIHZhciBvYmogPSB0aGlzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGxlZnQ6IG9iai5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxcbiAgICAgICAgdG9wOiBvYmoudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxcbiAgICAgICAgd2lkdGg6IE1hdGgucm91bmQob2JqLndpZHRoKSxcXG4gICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChvYmouaGVpZ2h0KVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgY3NzOiBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUpe1xcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzWzBdXFxuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuXFxuICAgICAgICAgIHJldHVybiBlbGVtZW50LnN0eWxlW2NhbWVsaXplKHByb3BlcnR5KV0gfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnJykuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSlcXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShwcm9wZXJ0eSkpIHtcXG4gICAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm5cXG4gICAgICAgICAgdmFyIHByb3BzID0ge31cXG4gICAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICcnKVxcbiAgICAgICAgICAkLmVhY2gocHJvcGVydHksIGZ1bmN0aW9uKF8sIHByb3Ape1xcbiAgICAgICAgICAgIHByb3BzW3Byb3BdID0gKGVsZW1lbnQuc3R5bGVbY2FtZWxpemUocHJvcCldIHx8IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKSlcXG4gICAgICAgICAgfSlcXG4gICAgICAgICAgcmV0dXJuIHByb3BzXFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBjc3MgPSAnJ1xcbiAgICAgIGlmICh0eXBlKHByb3BlcnR5KSA9PSAnc3RyaW5nJykge1xcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMClcXG4gICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCl7IHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkoZGFzaGVyaXplKHByb3BlcnR5KSkgfSlcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgY3NzID0gZGFzaGVyaXplKHByb3BlcnR5KSArIFxcXCI6XFxcIiArIG1heWJlQWRkUHgocHJvcGVydHksIHZhbHVlKVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBmb3IgKGtleSBpbiBwcm9wZXJ0eSlcXG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eVtrZXldICYmIHByb3BlcnR5W2tleV0gIT09IDApXFxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCl7IHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkoZGFzaGVyaXplKGtleSkpIH0pXFxuICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICBjc3MgKz0gZGFzaGVyaXplKGtleSkgKyAnOicgKyBtYXliZUFkZFB4KGtleSwgcHJvcGVydHlba2V5XSkgKyAnOydcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLnN0eWxlLmNzc1RleHQgKz0gJzsnICsgY3NzIH0pXFxuICAgIH0sXFxuICAgIGluZGV4OiBmdW5jdGlvbihlbGVtZW50KXtcXG4gICAgICByZXR1cm4gZWxlbWVudCA/IHRoaXMuaW5kZXhPZigkKGVsZW1lbnQpWzBdKSA6IHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5pbmRleE9mKHRoaXNbMF0pXFxuICAgIH0sXFxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihuYW1lKXtcXG4gICAgICBpZiAoIW5hbWUpIHJldHVybiBmYWxzZVxcbiAgICAgIHJldHVybiBlbXB0eUFycmF5LnNvbWUuY2FsbCh0aGlzLCBmdW5jdGlvbihlbCl7XFxuICAgICAgICByZXR1cm4gdGhpcy50ZXN0KGNsYXNzTmFtZShlbCkpXFxuICAgICAgfSwgY2xhc3NSRShuYW1lKSlcXG4gICAgfSxcXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKG5hbWUpe1xcbiAgICAgIGlmICghbmFtZSkgcmV0dXJuIHRoaXNcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICBpZiAoISgnY2xhc3NOYW1lJyBpbiB0aGlzKSkgcmV0dXJuXFxuICAgICAgICBjbGFzc0xpc3QgPSBbXVxcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzTmFtZSh0aGlzKSwgbmV3TmFtZSA9IGZ1bmNBcmcodGhpcywgbmFtZSwgaWR4LCBjbHMpXFxuICAgICAgICBuZXdOYW1lLnNwbGl0KC9cXFxccysvZykuZm9yRWFjaChmdW5jdGlvbihrbGFzcyl7XFxuICAgICAgICAgIGlmICghJCh0aGlzKS5oYXNDbGFzcyhrbGFzcykpIGNsYXNzTGlzdC5wdXNoKGtsYXNzKVxcbiAgICAgICAgfSwgdGhpcylcXG4gICAgICAgIGNsYXNzTGlzdC5sZW5ndGggJiYgY2xhc3NOYW1lKHRoaXMsIGNscyArIChjbHMgPyBcXFwiIFxcXCIgOiBcXFwiXFxcIikgKyBjbGFzc0xpc3Quam9pbihcXFwiIFxcXCIpKVxcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihuYW1lKXtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICBpZiAoISgnY2xhc3NOYW1lJyBpbiB0aGlzKSkgcmV0dXJuXFxuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY2xhc3NOYW1lKHRoaXMsICcnKVxcbiAgICAgICAgY2xhc3NMaXN0ID0gY2xhc3NOYW1lKHRoaXMpXFxuICAgICAgICBmdW5jQXJnKHRoaXMsIG5hbWUsIGlkeCwgY2xhc3NMaXN0KS5zcGxpdCgvXFxcXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xcbiAgICAgICAgICBjbGFzc0xpc3QgPSBjbGFzc0xpc3QucmVwbGFjZShjbGFzc1JFKGtsYXNzKSwgXFxcIiBcXFwiKVxcbiAgICAgICAgfSlcXG4gICAgICAgIGNsYXNzTmFtZSh0aGlzLCBjbGFzc0xpc3QudHJpbSgpKVxcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbihuYW1lLCB3aGVuKXtcXG4gICAgICBpZiAoIW5hbWUpIHJldHVybiB0aGlzXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSwgbmFtZXMgPSBmdW5jQXJnKHRoaXMsIG5hbWUsIGlkeCwgY2xhc3NOYW1lKHRoaXMpKVxcbiAgICAgICAgbmFtZXMuc3BsaXQoL1xcXFxzKy9nKS5mb3JFYWNoKGZ1bmN0aW9uKGtsYXNzKXtcXG4gICAgICAgICAgKHdoZW4gPT09IHVuZGVmaW5lZCA/ICEkdGhpcy5oYXNDbGFzcyhrbGFzcykgOiB3aGVuKSA/XFxuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3Moa2xhc3MpIDogJHRoaXMucmVtb3ZlQ2xhc3Moa2xhc3MpXFxuICAgICAgICB9KVxcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIHNjcm9sbFRvcDogZnVuY3Rpb24odmFsdWUpe1xcbiAgICAgIGlmICghdGhpcy5sZW5ndGgpIHJldHVyblxcbiAgICAgIHZhciBoYXNTY3JvbGxUb3AgPSAnc2Nyb2xsVG9wJyBpbiB0aGlzWzBdXFxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBoYXNTY3JvbGxUb3AgPyB0aGlzWzBdLnNjcm9sbFRvcCA6IHRoaXNbMF0ucGFnZVlPZmZzZXRcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGhhc1Njcm9sbFRvcCA/XFxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvcCA9IHZhbHVlIH0gOlxcbiAgICAgICAgZnVuY3Rpb24oKXsgdGhpcy5zY3JvbGxUbyh0aGlzLnNjcm9sbFgsIHZhbHVlKSB9KVxcbiAgICB9LFxcbiAgICBzY3JvbGxMZWZ0OiBmdW5jdGlvbih2YWx1ZSl7XFxuICAgICAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuXFxuICAgICAgdmFyIGhhc1Njcm9sbExlZnQgPSAnc2Nyb2xsTGVmdCcgaW4gdGhpc1swXVxcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gaGFzU2Nyb2xsTGVmdCA/IHRoaXNbMF0uc2Nyb2xsTGVmdCA6IHRoaXNbMF0ucGFnZVhPZmZzZXRcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGhhc1Njcm9sbExlZnQgP1xcbiAgICAgICAgZnVuY3Rpb24oKXsgdGhpcy5zY3JvbGxMZWZ0ID0gdmFsdWUgfSA6XFxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvKHZhbHVlLCB0aGlzLnNjcm9sbFkpIH0pXFxuICAgIH0sXFxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcXG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cXG5cXG4gICAgICB2YXIgZWxlbSA9IHRoaXNbMF0sXFxuICAgICAgICAvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKSxcXG4gICAgICAgIC8vIEdldCBjb3JyZWN0IG9mZnNldHNcXG4gICAgICAgIG9mZnNldCAgICAgICA9IHRoaXMub2Zmc2V0KCksXFxuICAgICAgICBwYXJlbnRPZmZzZXQgPSByb290Tm9kZVJFLnRlc3Qob2Zmc2V0UGFyZW50WzBdLm5vZGVOYW1lKSA/IHsgdG9wOiAwLCBsZWZ0OiAwIH0gOiBvZmZzZXRQYXJlbnQub2Zmc2V0KClcXG5cXG4gICAgICAvLyBTdWJ0cmFjdCBlbGVtZW50IG1hcmdpbnNcXG4gICAgICAvLyBub3RlOiB3aGVuIGFuIGVsZW1lbnQgaGFzIG1hcmdpbjogYXV0byB0aGUgb2Zmc2V0TGVmdCBhbmQgbWFyZ2luTGVmdFxcbiAgICAgIC8vIGFyZSB0aGUgc2FtZSBpbiBTYWZhcmkgY2F1c2luZyBvZmZzZXQubGVmdCB0byBpbmNvcnJlY3RseSBiZSAwXFxuICAgICAgb2Zmc2V0LnRvcCAgLT0gcGFyc2VGbG9hdCggJChlbGVtKS5jc3MoJ21hcmdpbi10b3AnKSApIHx8IDBcXG4gICAgICBvZmZzZXQubGVmdCAtPSBwYXJzZUZsb2F0KCAkKGVsZW0pLmNzcygnbWFyZ2luLWxlZnQnKSApIHx8IDBcXG5cXG4gICAgICAvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcXG4gICAgICBwYXJlbnRPZmZzZXQudG9wICArPSBwYXJzZUZsb2F0KCAkKG9mZnNldFBhcmVudFswXSkuY3NzKCdib3JkZXItdG9wLXdpZHRoJykgKSB8fCAwXFxuICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0gcGFyc2VGbG9hdCggJChvZmZzZXRQYXJlbnRbMF0pLmNzcygnYm9yZGVyLWxlZnQtd2lkdGgnKSApIHx8IDBcXG5cXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgdHdvIG9mZnNldHNcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdG9wOiAgb2Zmc2V0LnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wLFxcbiAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdFxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXtcXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5ib2R5XFxuICAgICAgICB3aGlsZSAocGFyZW50ICYmICFyb290Tm9kZVJFLnRlc3QocGFyZW50Lm5vZGVOYW1lKSAmJiAkKHBhcmVudCkuY3NzKFxcXCJwb3NpdGlvblxcXCIpID09IFxcXCJzdGF0aWNcXFwiKVxcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQub2Zmc2V0UGFyZW50XFxuICAgICAgICByZXR1cm4gcGFyZW50XFxuICAgICAgfSlcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gZm9yIG5vd1xcbiAgJC5mbi5kZXRhY2ggPSAkLmZuLnJlbW92ZVxcblxcbiAgLy8gR2VuZXJhdGUgdGhlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIGZ1bmN0aW9uc1xcbiAgO1snd2lkdGgnLCAnaGVpZ2h0J10uZm9yRWFjaChmdW5jdGlvbihkaW1lbnNpb24pe1xcbiAgICB2YXIgZGltZW5zaW9uUHJvcGVydHkgPVxcbiAgICAgIGRpbWVuc2lvbi5yZXBsYWNlKC8uLywgZnVuY3Rpb24obSl7IHJldHVybiBtWzBdLnRvVXBwZXJDYXNlKCkgfSlcXG5cXG4gICAgJC5mbltkaW1lbnNpb25dID0gZnVuY3Rpb24odmFsdWUpe1xcbiAgICAgIHZhciBvZmZzZXQsIGVsID0gdGhpc1swXVxcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gaXNXaW5kb3coZWwpID8gZWxbJ2lubmVyJyArIGRpbWVuc2lvblByb3BlcnR5XSA6XFxuICAgICAgICBpc0RvY3VtZW50KGVsKSA/IGVsLmRvY3VtZW50RWxlbWVudFsnc2Nyb2xsJyArIGRpbWVuc2lvblByb3BlcnR5XSA6XFxuICAgICAgICAob2Zmc2V0ID0gdGhpcy5vZmZzZXQoKSkgJiYgb2Zmc2V0W2RpbWVuc2lvbl1cXG4gICAgICBlbHNlIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcXG4gICAgICAgIGVsID0gJCh0aGlzKVxcbiAgICAgICAgZWwuY3NzKGRpbWVuc2lvbiwgZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCBlbFtkaW1lbnNpb25dKCkpKVxcbiAgICAgIH0pXFxuICAgIH1cXG4gIH0pXFxuXFxuICBmdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgZnVuKSB7XFxuICAgIGZ1bihub2RlKVxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxcbiAgICAgIHRyYXZlcnNlTm9kZShub2RlLmNoaWxkTm9kZXNbaV0sIGZ1bilcXG4gIH1cXG5cXG4gIC8vIEdlbmVyYXRlIHRoZSBgYWZ0ZXJgLCBgcHJlcGVuZGAsIGBiZWZvcmVgLCBgYXBwZW5kYCxcXG4gIC8vIGBpbnNlcnRBZnRlcmAsIGBpbnNlcnRCZWZvcmVgLCBgYXBwZW5kVG9gLCBhbmQgYHByZXBlbmRUb2AgbWV0aG9kcy5cXG4gIGFkamFjZW5jeU9wZXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKG9wZXJhdG9yLCBvcGVyYXRvckluZGV4KSB7XFxuICAgIHZhciBpbnNpZGUgPSBvcGVyYXRvckluZGV4ICUgMiAvLz0+IHByZXBlbmQsIGFwcGVuZFxcblxcbiAgICAkLmZuW29wZXJhdG9yXSA9IGZ1bmN0aW9uKCl7XFxuICAgICAgLy8gYXJndW1lbnRzIGNhbiBiZSBub2RlcywgYXJyYXlzIG9mIG5vZGVzLCBaZXB0byBvYmplY3RzIGFuZCBIVE1MIHN0cmluZ3NcXG4gICAgICB2YXIgYXJnVHlwZSwgbm9kZXMgPSAkLm1hcChhcmd1bWVudHMsIGZ1bmN0aW9uKGFyZykge1xcbiAgICAgICAgICAgIHZhciBhcnIgPSBbXVxcbiAgICAgICAgICAgIGFyZ1R5cGUgPSB0eXBlKGFyZylcXG4gICAgICAgICAgICBpZiAoYXJnVHlwZSA9PSBcXFwiYXJyYXlcXFwiKSB7XFxuICAgICAgICAgICAgICBhcmcuZm9yRWFjaChmdW5jdGlvbihlbCkge1xcbiAgICAgICAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGFyci5wdXNoKGVsKVxcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgkLnplcHRvLmlzWihlbCkpIHJldHVybiBhcnIgPSBhcnIuY29uY2F0KGVsLmdldCgpKVxcbiAgICAgICAgICAgICAgICBhcnIgPSBhcnIuY29uY2F0KHplcHRvLmZyYWdtZW50KGVsKSlcXG4gICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICByZXR1cm4gYXJyXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09IFxcXCJvYmplY3RcXFwiIHx8IGFyZyA9PSBudWxsID9cXG4gICAgICAgICAgICAgIGFyZyA6IHplcHRvLmZyYWdtZW50KGFyZylcXG4gICAgICAgICAgfSksXFxuICAgICAgICAgIHBhcmVudCwgY29weUJ5Q2xvbmUgPSB0aGlzLmxlbmd0aCA+IDFcXG4gICAgICBpZiAobm9kZXMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXNcXG5cXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKF8sIHRhcmdldCl7XFxuICAgICAgICBwYXJlbnQgPSBpbnNpZGUgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50Tm9kZVxcblxcbiAgICAgICAgLy8gY29udmVydCBhbGwgbWV0aG9kcyB0byBhIFxcXCJiZWZvcmVcXFwiIG9wZXJhdGlvblxcbiAgICAgICAgdGFyZ2V0ID0gb3BlcmF0b3JJbmRleCA9PSAwID8gdGFyZ2V0Lm5leHRTaWJsaW5nIDpcXG4gICAgICAgICAgICAgICAgIG9wZXJhdG9ySW5kZXggPT0gMSA/IHRhcmdldC5maXJzdENoaWxkIDpcXG4gICAgICAgICAgICAgICAgIG9wZXJhdG9ySW5kZXggPT0gMiA/IHRhcmdldCA6XFxuICAgICAgICAgICAgICAgICBudWxsXFxuXFxuICAgICAgICB2YXIgcGFyZW50SW5Eb2N1bWVudCA9ICQuY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBwYXJlbnQpXFxuXFxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpe1xcbiAgICAgICAgICBpZiAoY29weUJ5Q2xvbmUpIG5vZGUgPSBub2RlLmNsb25lTm9kZSh0cnVlKVxcbiAgICAgICAgICBlbHNlIGlmICghcGFyZW50KSByZXR1cm4gJChub2RlKS5yZW1vdmUoKVxcblxcbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldClcXG4gICAgICAgICAgaWYgKHBhcmVudEluRG9jdW1lbnQpIHRyYXZlcnNlTm9kZShub2RlLCBmdW5jdGlvbihlbCl7XFxuICAgICAgICAgICAgaWYgKGVsLm5vZGVOYW1lICE9IG51bGwgJiYgZWwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1NDUklQVCcgJiZcXG4gICAgICAgICAgICAgICAoIWVsLnR5cGUgfHwgZWwudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCcpICYmICFlbC5zcmMpe1xcbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGVsLm93bmVyRG9jdW1lbnQgPyBlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93XFxuICAgICAgICAgICAgICB0YXJnZXRbJ2V2YWwnXS5jYWxsKHRhcmdldCwgZWwuaW5uZXJIVE1MKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSlcXG4gICAgICAgIH0pXFxuICAgICAgfSlcXG4gICAgfVxcblxcbiAgICAvLyBhZnRlciAgICA9PiBpbnNlcnRBZnRlclxcbiAgICAvLyBwcmVwZW5kICA9PiBwcmVwZW5kVG9cXG4gICAgLy8gYmVmb3JlICAgPT4gaW5zZXJ0QmVmb3JlXFxuICAgIC8vIGFwcGVuZCAgID0+IGFwcGVuZFRvXFxuICAgICQuZm5baW5zaWRlID8gb3BlcmF0b3IrJ1RvJyA6ICdpbnNlcnQnKyhvcGVyYXRvckluZGV4ID8gJ0JlZm9yZScgOiAnQWZ0ZXInKV0gPSBmdW5jdGlvbihodG1sKXtcXG4gICAgICAkKGh0bWwpW29wZXJhdG9yXSh0aGlzKVxcbiAgICAgIHJldHVybiB0aGlzXFxuICAgIH1cXG4gIH0pXFxuXFxuICB6ZXB0by5aLnByb3RvdHlwZSA9IFoucHJvdG90eXBlID0gJC5mblxcblxcbiAgLy8gRXhwb3J0IGludGVybmFsIEFQSSBmdW5jdGlvbnMgaW4gdGhlIGAkLnplcHRvYCBuYW1lc3BhY2VcXG4gIHplcHRvLnVuaXEgPSB1bmlxXFxuICB6ZXB0by5kZXNlcmlhbGl6ZVZhbHVlID0gZGVzZXJpYWxpemVWYWx1ZVxcbiAgJC56ZXB0byA9IHplcHRvXFxuXFxuICByZXR1cm4gJFxcbn0pKClcXG5cXG53aW5kb3cuWmVwdG8gPSBaZXB0b1xcbndpbmRvdy4kID09PSB1bmRlZmluZWQgJiYgKHdpbmRvdy4kID0gWmVwdG8pXFxuXFxuOyhmdW5jdGlvbigkKXtcXG4gIHZhciBfemlkID0gMSwgdW5kZWZpbmVkLFxcbiAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxcbiAgICAgIGlzRnVuY3Rpb24gPSAkLmlzRnVuY3Rpb24sXFxuICAgICAgaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopeyByZXR1cm4gdHlwZW9mIG9iaiA9PSAnc3RyaW5nJyB9LFxcbiAgICAgIGhhbmRsZXJzID0ge30sXFxuICAgICAgc3BlY2lhbEV2ZW50cz17fSxcXG4gICAgICBmb2N1c2luU3VwcG9ydGVkID0gJ29uZm9jdXNpbicgaW4gd2luZG93LFxcbiAgICAgIGZvY3VzID0geyBmb2N1czogJ2ZvY3VzaW4nLCBibHVyOiAnZm9jdXNvdXQnIH0sXFxuICAgICAgaG92ZXIgPSB7IG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLCBtb3VzZWxlYXZlOiAnbW91c2VvdXQnIH1cXG5cXG4gIHNwZWNpYWxFdmVudHMuY2xpY2sgPSBzcGVjaWFsRXZlbnRzLm1vdXNlZG93biA9IHNwZWNpYWxFdmVudHMubW91c2V1cCA9IHNwZWNpYWxFdmVudHMubW91c2Vtb3ZlID0gJ01vdXNlRXZlbnRzJ1xcblxcbiAgZnVuY3Rpb24gemlkKGVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIGVsZW1lbnQuX3ppZCB8fCAoZWxlbWVudC5femlkID0gX3ppZCsrKVxcbiAgfVxcbiAgZnVuY3Rpb24gZmluZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50LCBmbiwgc2VsZWN0b3IpIHtcXG4gICAgZXZlbnQgPSBwYXJzZShldmVudClcXG4gICAgaWYgKGV2ZW50Lm5zKSB2YXIgbWF0Y2hlciA9IG1hdGNoZXJGb3IoZXZlbnQubnMpXFxuICAgIHJldHVybiAoaGFuZGxlcnNbemlkKGVsZW1lbnQpXSB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uKGhhbmRsZXIpIHtcXG4gICAgICByZXR1cm4gaGFuZGxlclxcbiAgICAgICAgJiYgKCFldmVudC5lICB8fCBoYW5kbGVyLmUgPT0gZXZlbnQuZSlcXG4gICAgICAgICYmICghZXZlbnQubnMgfHwgbWF0Y2hlci50ZXN0KGhhbmRsZXIubnMpKVxcbiAgICAgICAgJiYgKCFmbiAgICAgICB8fCB6aWQoaGFuZGxlci5mbikgPT09IHppZChmbikpXFxuICAgICAgICAmJiAoIXNlbGVjdG9yIHx8IGhhbmRsZXIuc2VsID09IHNlbGVjdG9yKVxcbiAgICB9KVxcbiAgfVxcbiAgZnVuY3Rpb24gcGFyc2UoZXZlbnQpIHtcXG4gICAgdmFyIHBhcnRzID0gKCcnICsgZXZlbnQpLnNwbGl0KCcuJylcXG4gICAgcmV0dXJuIHtlOiBwYXJ0c1swXSwgbnM6IHBhcnRzLnNsaWNlKDEpLnNvcnQoKS5qb2luKCcgJyl9XFxuICB9XFxuICBmdW5jdGlvbiBtYXRjaGVyRm9yKG5zKSB7XFxuICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefCApJyArIG5zLnJlcGxhY2UoJyAnLCAnIC4qID8nKSArICcoPzogfCQpJylcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGV2ZW50Q2FwdHVyZShoYW5kbGVyLCBjYXB0dXJlU2V0dGluZykge1xcbiAgICByZXR1cm4gaGFuZGxlci5kZWwgJiZcXG4gICAgICAoIWZvY3VzaW5TdXBwb3J0ZWQgJiYgKGhhbmRsZXIuZSBpbiBmb2N1cykpIHx8XFxuICAgICAgISFjYXB0dXJlU2V0dGluZ1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVhbEV2ZW50KHR5cGUpIHtcXG4gICAgcmV0dXJuIGhvdmVyW3R5cGVdIHx8IChmb2N1c2luU3VwcG9ydGVkICYmIGZvY3VzW3R5cGVdKSB8fCB0eXBlXFxuICB9XFxuXFxuICBmdW5jdGlvbiBhZGQoZWxlbWVudCwgZXZlbnRzLCBmbiwgZGF0YSwgc2VsZWN0b3IsIGRlbGVnYXRvciwgY2FwdHVyZSl7XFxuICAgIHZhciBpZCA9IHppZChlbGVtZW50KSwgc2V0ID0gKGhhbmRsZXJzW2lkXSB8fCAoaGFuZGxlcnNbaWRdID0gW10pKVxcbiAgICBldmVudHMuc3BsaXQoL1xcXFxzLykuZm9yRWFjaChmdW5jdGlvbihldmVudCl7XFxuICAgICAgaWYgKGV2ZW50ID09ICdyZWFkeScpIHJldHVybiAkKGRvY3VtZW50KS5yZWFkeShmbilcXG4gICAgICB2YXIgaGFuZGxlciAgID0gcGFyc2UoZXZlbnQpXFxuICAgICAgaGFuZGxlci5mbiAgICA9IGZuXFxuICAgICAgaGFuZGxlci5zZWwgICA9IHNlbGVjdG9yXFxuICAgICAgLy8gZW11bGF0ZSBtb3VzZWVudGVyLCBtb3VzZWxlYXZlXFxuICAgICAgaWYgKGhhbmRsZXIuZSBpbiBob3ZlcikgZm4gPSBmdW5jdGlvbihlKXtcXG4gICAgICAgIHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0XFxuICAgICAgICBpZiAoIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRoaXMgJiYgISQuY29udGFpbnModGhpcywgcmVsYXRlZCkpKVxcbiAgICAgICAgICByZXR1cm4gaGFuZGxlci5mbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXFxuICAgICAgfVxcbiAgICAgIGhhbmRsZXIuZGVsICAgPSBkZWxlZ2F0b3JcXG4gICAgICB2YXIgY2FsbGJhY2sgID0gZGVsZWdhdG9yIHx8IGZuXFxuICAgICAgaGFuZGxlci5wcm94eSA9IGZ1bmN0aW9uKGUpe1xcbiAgICAgICAgZSA9IGNvbXBhdGlibGUoZSlcXG4gICAgICAgIGlmIChlLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHJldHVyblxcbiAgICAgICAgZS5kYXRhID0gZGF0YVxcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrLmFwcGx5KGVsZW1lbnQsIGUuX2FyZ3MgPT0gdW5kZWZpbmVkID8gW2VdIDogW2VdLmNvbmNhdChlLl9hcmdzKSlcXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcFByb3BhZ2F0aW9uKClcXG4gICAgICAgIHJldHVybiByZXN1bHRcXG4gICAgICB9XFxuICAgICAgaGFuZGxlci5pID0gc2V0Lmxlbmd0aFxcbiAgICAgIHNldC5wdXNoKGhhbmRsZXIpXFxuICAgICAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBlbGVtZW50KVxcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHJlYWxFdmVudChoYW5kbGVyLmUpLCBoYW5kbGVyLnByb3h5LCBldmVudENhcHR1cmUoaGFuZGxlciwgY2FwdHVyZSkpXFxuICAgIH0pXFxuICB9XFxuICBmdW5jdGlvbiByZW1vdmUoZWxlbWVudCwgZXZlbnRzLCBmbiwgc2VsZWN0b3IsIGNhcHR1cmUpe1xcbiAgICB2YXIgaWQgPSB6aWQoZWxlbWVudClcXG4gICAgOyhldmVudHMgfHwgJycpLnNwbGl0KC9cXFxccy8pLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpe1xcbiAgICAgIGZpbmRIYW5kbGVycyhlbGVtZW50LCBldmVudCwgZm4sIHNlbGVjdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpe1xcbiAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2lkXVtoYW5kbGVyLmldXFxuICAgICAgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBlbGVtZW50KVxcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHJlYWxFdmVudChoYW5kbGVyLmUpLCBoYW5kbGVyLnByb3h5LCBldmVudENhcHR1cmUoaGFuZGxlciwgY2FwdHVyZSkpXFxuICAgICAgfSlcXG4gICAgfSlcXG4gIH1cXG5cXG4gICQuZXZlbnQgPSB7IGFkZDogYWRkLCByZW1vdmU6IHJlbW92ZSB9XFxuXFxuICAkLnByb3h5ID0gZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcXG4gICAgdmFyIGFyZ3MgPSAoMiBpbiBhcmd1bWVudHMpICYmIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKVxcbiAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcXG4gICAgICB2YXIgcHJveHlGbiA9IGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cykgfVxcbiAgICAgIHByb3h5Rm4uX3ppZCA9IHppZChmbilcXG4gICAgICByZXR1cm4gcHJveHlGblxcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGNvbnRleHQpKSB7XFxuICAgICAgaWYgKGFyZ3MpIHtcXG4gICAgICAgIGFyZ3MudW5zaGlmdChmbltjb250ZXh0XSwgZm4pXFxuICAgICAgICByZXR1cm4gJC5wcm94eS5hcHBseShudWxsLCBhcmdzKVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gJC5wcm94eShmbltjb250ZXh0XSwgZm4pXFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcImV4cGVjdGVkIGZ1bmN0aW9uXFxcIilcXG4gICAgfVxcbiAgfVxcblxcbiAgJC5mbi5iaW5kID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEsIGNhbGxiYWNrKXtcXG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGRhdGEsIGNhbGxiYWNrKVxcbiAgfVxcbiAgJC5mbi51bmJpbmQgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spe1xcbiAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnQsIGNhbGxiYWNrKVxcbiAgfVxcbiAgJC5mbi5vbmUgPSBmdW5jdGlvbihldmVudCwgc2VsZWN0b3IsIGRhdGEsIGNhbGxiYWNrKXtcXG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIHNlbGVjdG9yLCBkYXRhLCBjYWxsYmFjaywgMSlcXG4gIH1cXG5cXG4gIHZhciByZXR1cm5UcnVlID0gZnVuY3Rpb24oKXtyZXR1cm4gdHJ1ZX0sXFxuICAgICAgcmV0dXJuRmFsc2UgPSBmdW5jdGlvbigpe3JldHVybiBmYWxzZX0sXFxuICAgICAgaWdub3JlUHJvcGVydGllcyA9IC9eKFtBLVpdfHJldHVyblZhbHVlJHxsYXllcltYWV0kfHdlYmtpdE1vdmVtZW50W1hZXSQpLyxcXG4gICAgICBldmVudE1ldGhvZHMgPSB7XFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogJ2lzRGVmYXVsdFByZXZlbnRlZCcsXFxuICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246ICdpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCcsXFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246ICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCdcXG4gICAgICB9XFxuXFxuICBmdW5jdGlvbiBjb21wYXRpYmxlKGV2ZW50LCBzb3VyY2UpIHtcXG4gICAgaWYgKHNvdXJjZSB8fCAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgc291cmNlIHx8IChzb3VyY2UgPSBldmVudClcXG5cXG4gICAgICAkLmVhY2goZXZlbnRNZXRob2RzLCBmdW5jdGlvbihuYW1lLCBwcmVkaWNhdGUpIHtcXG4gICAgICAgIHZhciBzb3VyY2VNZXRob2QgPSBzb3VyY2VbbmFtZV1cXG4gICAgICAgIGV2ZW50W25hbWVdID0gZnVuY3Rpb24oKXtcXG4gICAgICAgICAgdGhpc1twcmVkaWNhdGVdID0gcmV0dXJuVHJ1ZVxcbiAgICAgICAgICByZXR1cm4gc291cmNlTWV0aG9kICYmIHNvdXJjZU1ldGhvZC5hcHBseShzb3VyY2UsIGFyZ3VtZW50cylcXG4gICAgICAgIH1cXG4gICAgICAgIGV2ZW50W3ByZWRpY2F0ZV0gPSByZXR1cm5GYWxzZVxcbiAgICAgIH0pXFxuXFxuICAgICAgZXZlbnQudGltZVN0YW1wIHx8IChldmVudC50aW1lU3RhbXAgPSBEYXRlLm5vdygpKVxcblxcbiAgICAgIGlmIChzb3VyY2UuZGVmYXVsdFByZXZlbnRlZCAhPT0gdW5kZWZpbmVkID8gc291cmNlLmRlZmF1bHRQcmV2ZW50ZWQgOlxcbiAgICAgICAgICAncmV0dXJuVmFsdWUnIGluIHNvdXJjZSA/IHNvdXJjZS5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgOlxcbiAgICAgICAgICBzb3VyY2UuZ2V0UHJldmVudERlZmF1bHQgJiYgc291cmNlLmdldFByZXZlbnREZWZhdWx0KCkpXFxuICAgICAgICBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlXFxuICAgIH1cXG4gICAgcmV0dXJuIGV2ZW50XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVQcm94eShldmVudCkge1xcbiAgICB2YXIga2V5LCBwcm94eSA9IHsgb3JpZ2luYWxFdmVudDogZXZlbnQgfVxcbiAgICBmb3IgKGtleSBpbiBldmVudClcXG4gICAgICBpZiAoIWlnbm9yZVByb3BlcnRpZXMudGVzdChrZXkpICYmIGV2ZW50W2tleV0gIT09IHVuZGVmaW5lZCkgcHJveHlba2V5XSA9IGV2ZW50W2tleV1cXG5cXG4gICAgcmV0dXJuIGNvbXBhdGlibGUocHJveHksIGV2ZW50KVxcbiAgfVxcblxcbiAgJC5mbi5kZWxlZ2F0ZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBldmVudCwgY2FsbGJhY2spe1xcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgc2VsZWN0b3IsIGNhbGxiYWNrKVxcbiAgfVxcbiAgJC5mbi51bmRlbGVnYXRlID0gZnVuY3Rpb24oc2VsZWN0b3IsIGV2ZW50LCBjYWxsYmFjayl7XFxuICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgc2VsZWN0b3IsIGNhbGxiYWNrKVxcbiAgfVxcblxcbiAgJC5mbi5saXZlID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKXtcXG4gICAgJChkb2N1bWVudC5ib2R5KS5kZWxlZ2F0ZSh0aGlzLnNlbGVjdG9yLCBldmVudCwgY2FsbGJhY2spXFxuICAgIHJldHVybiB0aGlzXFxuICB9XFxuICAkLmZuLmRpZSA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjayl7XFxuICAgICQoZG9jdW1lbnQuYm9keSkudW5kZWxlZ2F0ZSh0aGlzLnNlbGVjdG9yLCBldmVudCwgY2FsbGJhY2spXFxuICAgIHJldHVybiB0aGlzXFxuICB9XFxuXFxuICAkLmZuLm9uID0gZnVuY3Rpb24oZXZlbnQsIHNlbGVjdG9yLCBkYXRhLCBjYWxsYmFjaywgb25lKXtcXG4gICAgdmFyIGF1dG9SZW1vdmUsIGRlbGVnYXRvciwgJHRoaXMgPSB0aGlzXFxuICAgIGlmIChldmVudCAmJiAhaXNTdHJpbmcoZXZlbnQpKSB7XFxuICAgICAgJC5lYWNoKGV2ZW50LCBmdW5jdGlvbih0eXBlLCBmbil7XFxuICAgICAgICAkdGhpcy5vbih0eXBlLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSlcXG4gICAgICB9KVxcbiAgICAgIHJldHVybiAkdGhpc1xcbiAgICB9XFxuXFxuICAgIGlmICghaXNTdHJpbmcoc2VsZWN0b3IpICYmICFpc0Z1bmN0aW9uKGNhbGxiYWNrKSAmJiBjYWxsYmFjayAhPT0gZmFsc2UpXFxuICAgICAgY2FsbGJhY2sgPSBkYXRhLCBkYXRhID0gc2VsZWN0b3IsIHNlbGVjdG9yID0gdW5kZWZpbmVkXFxuICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09IGZhbHNlKVxcbiAgICAgIGNhbGxiYWNrID0gZGF0YSwgZGF0YSA9IHVuZGVmaW5lZFxcblxcbiAgICBpZiAoY2FsbGJhY2sgPT09IGZhbHNlKSBjYWxsYmFjayA9IHJldHVybkZhbHNlXFxuXFxuICAgIHJldHVybiAkdGhpcy5lYWNoKGZ1bmN0aW9uKF8sIGVsZW1lbnQpe1xcbiAgICAgIGlmIChvbmUpIGF1dG9SZW1vdmUgPSBmdW5jdGlvbihlKXtcXG4gICAgICAgIHJlbW92ZShlbGVtZW50LCBlLnR5cGUsIGNhbGxiYWNrKVxcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHNlbGVjdG9yKSBkZWxlZ2F0b3IgPSBmdW5jdGlvbihlKXtcXG4gICAgICAgIHZhciBldnQsIG1hdGNoID0gJChlLnRhcmdldCkuY2xvc2VzdChzZWxlY3RvciwgZWxlbWVudCkuZ2V0KDApXFxuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2ggIT09IGVsZW1lbnQpIHtcXG4gICAgICAgICAgZXZ0ID0gJC5leHRlbmQoY3JlYXRlUHJveHkoZSksIHtjdXJyZW50VGFyZ2V0OiBtYXRjaCwgbGl2ZUZpcmVkOiBlbGVtZW50fSlcXG4gICAgICAgICAgcmV0dXJuIChhdXRvUmVtb3ZlIHx8IGNhbGxiYWNrKS5hcHBseShtYXRjaCwgW2V2dF0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpXFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGFkZChlbGVtZW50LCBldmVudCwgY2FsbGJhY2ssIGRhdGEsIHNlbGVjdG9yLCBkZWxlZ2F0b3IgfHwgYXV0b1JlbW92ZSlcXG4gICAgfSlcXG4gIH1cXG4gICQuZm4ub2ZmID0gZnVuY3Rpb24oZXZlbnQsIHNlbGVjdG9yLCBjYWxsYmFjayl7XFxuICAgIHZhciAkdGhpcyA9IHRoaXNcXG4gICAgaWYgKGV2ZW50ICYmICFpc1N0cmluZyhldmVudCkpIHtcXG4gICAgICAkLmVhY2goZXZlbnQsIGZ1bmN0aW9uKHR5cGUsIGZuKXtcXG4gICAgICAgICR0aGlzLm9mZih0eXBlLCBzZWxlY3RvciwgZm4pXFxuICAgICAgfSlcXG4gICAgICByZXR1cm4gJHRoaXNcXG4gICAgfVxcblxcbiAgICBpZiAoIWlzU3RyaW5nKHNlbGVjdG9yKSAmJiAhaXNGdW5jdGlvbihjYWxsYmFjaykgJiYgY2FsbGJhY2sgIT09IGZhbHNlKVxcbiAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3IsIHNlbGVjdG9yID0gdW5kZWZpbmVkXFxuXFxuICAgIGlmIChjYWxsYmFjayA9PT0gZmFsc2UpIGNhbGxiYWNrID0gcmV0dXJuRmFsc2VcXG5cXG4gICAgcmV0dXJuICR0aGlzLmVhY2goZnVuY3Rpb24oKXtcXG4gICAgICByZW1vdmUodGhpcywgZXZlbnQsIGNhbGxiYWNrLCBzZWxlY3RvcilcXG4gICAgfSlcXG4gIH1cXG5cXG4gICQuZm4udHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50LCBhcmdzKXtcXG4gICAgZXZlbnQgPSAoaXNTdHJpbmcoZXZlbnQpIHx8ICQuaXNQbGFpbk9iamVjdChldmVudCkpID8gJC5FdmVudChldmVudCkgOiBjb21wYXRpYmxlKGV2ZW50KVxcbiAgICBldmVudC5fYXJncyA9IGFyZ3NcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xcbiAgICAgIC8vIGhhbmRsZSBmb2N1cygpLCBibHVyKCkgYnkgY2FsbGluZyB0aGVtIGRpcmVjdGx5XFxuICAgICAgaWYgKGV2ZW50LnR5cGUgaW4gZm9jdXMgJiYgdHlwZW9mIHRoaXNbZXZlbnQudHlwZV0gPT0gXFxcImZ1bmN0aW9uXFxcIikgdGhpc1tldmVudC50eXBlXSgpXFxuICAgICAgLy8gaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gbWlnaHQgbm90IGJlIERPTSBlbGVtZW50c1xcbiAgICAgIGVsc2UgaWYgKCdkaXNwYXRjaEV2ZW50JyBpbiB0aGlzKSB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpXFxuICAgICAgZWxzZSAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKGV2ZW50LCBhcmdzKVxcbiAgICB9KVxcbiAgfVxcblxcbiAgLy8gdHJpZ2dlcnMgZXZlbnQgaGFuZGxlcnMgb24gY3VycmVudCBlbGVtZW50IGp1c3QgYXMgaWYgYW4gZXZlbnQgb2NjdXJyZWQsXFxuICAvLyBkb2Vzbid0IHRyaWdnZXIgYW4gYWN0dWFsIGV2ZW50LCBkb2Vzbid0IGJ1YmJsZVxcbiAgJC5mbi50cmlnZ2VySGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50LCBhcmdzKXtcXG4gICAgdmFyIGUsIHJlc3VsdFxcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSwgZWxlbWVudCl7XFxuICAgICAgZSA9IGNyZWF0ZVByb3h5KGlzU3RyaW5nKGV2ZW50KSA/ICQuRXZlbnQoZXZlbnQpIDogZXZlbnQpXFxuICAgICAgZS5fYXJncyA9IGFyZ3NcXG4gICAgICBlLnRhcmdldCA9IGVsZW1lbnRcXG4gICAgICAkLmVhY2goZmluZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50LnR5cGUgfHwgZXZlbnQpLCBmdW5jdGlvbihpLCBoYW5kbGVyKXtcXG4gICAgICAgIHJlc3VsdCA9IGhhbmRsZXIucHJveHkoZSlcXG4gICAgICAgIGlmIChlLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHJldHVybiBmYWxzZVxcbiAgICAgIH0pXFxuICAgIH0pXFxuICAgIHJldHVybiByZXN1bHRcXG4gIH1cXG5cXG4gIC8vIHNob3J0Y3V0IG1ldGhvZHMgZm9yIGAuYmluZChldmVudCwgZm4pYCBmb3IgZWFjaCBldmVudCB0eXBlXFxuICA7KCdmb2N1c2luIGZvY3Vzb3V0IGZvY3VzIGJsdXIgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayAnK1xcbiAgJ21vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlICcrXFxuICAnY2hhbmdlIHNlbGVjdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yJykuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XFxuICAgICQuZm5bZXZlbnRdID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcXG4gICAgICByZXR1cm4gKDAgaW4gYXJndW1lbnRzKSA/XFxuICAgICAgICB0aGlzLmJpbmQoZXZlbnQsIGNhbGxiYWNrKSA6XFxuICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnQpXFxuICAgIH1cXG4gIH0pXFxuXFxuICAkLkV2ZW50ID0gZnVuY3Rpb24odHlwZSwgcHJvcHMpIHtcXG4gICAgaWYgKCFpc1N0cmluZyh0eXBlKSkgcHJvcHMgPSB0eXBlLCB0eXBlID0gcHJvcHMudHlwZVxcbiAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChzcGVjaWFsRXZlbnRzW3R5cGVdIHx8ICdFdmVudHMnKSwgYnViYmxlcyA9IHRydWVcXG4gICAgaWYgKHByb3BzKSBmb3IgKHZhciBuYW1lIGluIHByb3BzKSAobmFtZSA9PSAnYnViYmxlcycpID8gKGJ1YmJsZXMgPSAhIXByb3BzW25hbWVdKSA6IChldmVudFtuYW1lXSA9IHByb3BzW25hbWVdKVxcbiAgICBldmVudC5pbml0RXZlbnQodHlwZSwgYnViYmxlcywgdHJ1ZSlcXG4gICAgcmV0dXJuIGNvbXBhdGlibGUoZXZlbnQpXFxuICB9XFxuXFxufSkoWmVwdG8pXFxuXFxuOyhmdW5jdGlvbigkKXtcXG4gIHZhciBqc29ucElEID0gK25ldyBEYXRlKCksXFxuICAgICAgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXFxuICAgICAga2V5LFxcbiAgICAgIG5hbWUsXFxuICAgICAgcnNjcmlwdCA9IC88c2NyaXB0XFxcXGJbXjxdKig/Oig/ITxcXFxcL3NjcmlwdD4pPFtePF0qKSo8XFxcXC9zY3JpcHQ+L2dpLFxcbiAgICAgIHNjcmlwdFR5cGVSRSA9IC9eKD86dGV4dHxhcHBsaWNhdGlvbilcXFxcL2phdmFzY3JpcHQvaSxcXG4gICAgICB4bWxUeXBlUkUgPSAvXig/OnRleHR8YXBwbGljYXRpb24pXFxcXC94bWwvaSxcXG4gICAgICBqc29uVHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJyxcXG4gICAgICBodG1sVHlwZSA9ICd0ZXh0L2h0bWwnLFxcbiAgICAgIGJsYW5rUkUgPSAvXlxcXFxzKiQvLFxcbiAgICAgIG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxcblxcbiAgb3JpZ2luQW5jaG9yLmhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxcblxcbiAgLy8gdHJpZ2dlciBhIGN1c3RvbSBldmVudCBhbmQgcmV0dXJuIGZhbHNlIGlmIGl0IHdhcyBjYW5jZWxsZWRcXG4gIGZ1bmN0aW9uIHRyaWdnZXJBbmRSZXR1cm4oY29udGV4dCwgZXZlbnROYW1lLCBkYXRhKSB7XFxuICAgIHZhciBldmVudCA9ICQuRXZlbnQoZXZlbnROYW1lKVxcbiAgICAkKGNvbnRleHQpLnRyaWdnZXIoZXZlbnQsIGRhdGEpXFxuICAgIHJldHVybiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKClcXG4gIH1cXG5cXG4gIC8vIHRyaWdnZXIgYW4gQWpheCBcXFwiZ2xvYmFsXFxcIiBldmVudFxcbiAgZnVuY3Rpb24gdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgZXZlbnROYW1lLCBkYXRhKSB7XFxuICAgIGlmIChzZXR0aW5ncy5nbG9iYWwpIHJldHVybiB0cmlnZ2VyQW5kUmV0dXJuKGNvbnRleHQgfHwgZG9jdW1lbnQsIGV2ZW50TmFtZSwgZGF0YSlcXG4gIH1cXG5cXG4gIC8vIE51bWJlciBvZiBhY3RpdmUgQWpheCByZXF1ZXN0c1xcbiAgJC5hY3RpdmUgPSAwXFxuXFxuICBmdW5jdGlvbiBhamF4U3RhcnQoc2V0dGluZ3MpIHtcXG4gICAgaWYgKHNldHRpbmdzLmdsb2JhbCAmJiAkLmFjdGl2ZSsrID09PSAwKSB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBudWxsLCAnYWpheFN0YXJ0JylcXG4gIH1cXG4gIGZ1bmN0aW9uIGFqYXhTdG9wKHNldHRpbmdzKSB7XFxuICAgIGlmIChzZXR0aW5ncy5nbG9iYWwgJiYgISgtLSQuYWN0aXZlKSkgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgbnVsbCwgJ2FqYXhTdG9wJylcXG4gIH1cXG5cXG4gIC8vIHRyaWdnZXJzIGFuIGV4dHJhIGdsb2JhbCBldmVudCBcXFwiYWpheEJlZm9yZVNlbmRcXFwiIHRoYXQncyBsaWtlIFxcXCJhamF4U2VuZFxcXCIgYnV0IGNhbmNlbGFibGVcXG4gIGZ1bmN0aW9uIGFqYXhCZWZvcmVTZW5kKHhociwgc2V0dGluZ3MpIHtcXG4gICAgdmFyIGNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0XFxuICAgIGlmIChzZXR0aW5ncy5iZWZvcmVTZW5kLmNhbGwoY29udGV4dCwgeGhyLCBzZXR0aW5ncykgPT09IGZhbHNlIHx8XFxuICAgICAgICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheEJlZm9yZVNlbmQnLCBbeGhyLCBzZXR0aW5nc10pID09PSBmYWxzZSlcXG4gICAgICByZXR1cm4gZmFsc2VcXG5cXG4gICAgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgJ2FqYXhTZW5kJywgW3hociwgc2V0dGluZ3NdKVxcbiAgfVxcbiAgZnVuY3Rpb24gYWpheFN1Y2Nlc3MoZGF0YSwgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpIHtcXG4gICAgdmFyIGNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0LCBzdGF0dXMgPSAnc3VjY2VzcydcXG4gICAgc2V0dGluZ3Muc3VjY2Vzcy5jYWxsKGNvbnRleHQsIGRhdGEsIHN0YXR1cywgeGhyKVxcbiAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnJlc29sdmVXaXRoKGNvbnRleHQsIFtkYXRhLCBzdGF0dXMsIHhocl0pXFxuICAgIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4U3VjY2VzcycsIFt4aHIsIHNldHRpbmdzLCBkYXRhXSlcXG4gICAgYWpheENvbXBsZXRlKHN0YXR1cywgeGhyLCBzZXR0aW5ncylcXG4gIH1cXG4gIC8vIHR5cGU6IFxcXCJ0aW1lb3V0XFxcIiwgXFxcImVycm9yXFxcIiwgXFxcImFib3J0XFxcIiwgXFxcInBhcnNlcmVycm9yXFxcIlxcbiAgZnVuY3Rpb24gYWpheEVycm9yKGVycm9yLCB0eXBlLCB4aHIsIHNldHRpbmdzLCBkZWZlcnJlZCkge1xcbiAgICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHRcXG4gICAgc2V0dGluZ3MuZXJyb3IuY2FsbChjb250ZXh0LCB4aHIsIHR5cGUsIGVycm9yKVxcbiAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnJlamVjdFdpdGgoY29udGV4dCwgW3hociwgdHlwZSwgZXJyb3JdKVxcbiAgICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheEVycm9yJywgW3hociwgc2V0dGluZ3MsIGVycm9yIHx8IHR5cGVdKVxcbiAgICBhamF4Q29tcGxldGUodHlwZSwgeGhyLCBzZXR0aW5ncylcXG4gIH1cXG4gIC8vIHN0YXR1czogXFxcInN1Y2Nlc3NcXFwiLCBcXFwibm90bW9kaWZpZWRcXFwiLCBcXFwiZXJyb3JcXFwiLCBcXFwidGltZW91dFxcXCIsIFxcXCJhYm9ydFxcXCIsIFxcXCJwYXJzZXJlcnJvclxcXCJcXG4gIGZ1bmN0aW9uIGFqYXhDb21wbGV0ZShzdGF0dXMsIHhociwgc2V0dGluZ3MpIHtcXG4gICAgdmFyIGNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0XFxuICAgIHNldHRpbmdzLmNvbXBsZXRlLmNhbGwoY29udGV4dCwgeGhyLCBzdGF0dXMpXFxuICAgIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4Q29tcGxldGUnLCBbeGhyLCBzZXR0aW5nc10pXFxuICAgIGFqYXhTdG9wKHNldHRpbmdzKVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gYWpheERhdGFGaWx0ZXIoZGF0YSwgdHlwZSwgc2V0dGluZ3MpIHtcXG4gICAgaWYgKHNldHRpbmdzLmRhdGFGaWx0ZXIgPT0gZW1wdHkpIHJldHVybiBkYXRhXFxuICAgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dFxcbiAgICByZXR1cm4gc2V0dGluZ3MuZGF0YUZpbHRlci5jYWxsKGNvbnRleHQsIGRhdGEsIHR5cGUpXFxuICB9XFxuXFxuICAvLyBFbXB0eSBmdW5jdGlvbiwgdXNlZCBhcyBkZWZhdWx0IGNhbGxiYWNrXFxuICBmdW5jdGlvbiBlbXB0eSgpIHt9XFxuXFxuICAkLmFqYXhKU09OUCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmVycmVkKXtcXG4gICAgaWYgKCEoJ3R5cGUnIGluIG9wdGlvbnMpKSByZXR1cm4gJC5hamF4KG9wdGlvbnMpXFxuXFxuICAgIHZhciBfY2FsbGJhY2tOYW1lID0gb3B0aW9ucy5qc29ucENhbGxiYWNrLFxcbiAgICAgIGNhbGxiYWNrTmFtZSA9ICgkLmlzRnVuY3Rpb24oX2NhbGxiYWNrTmFtZSkgP1xcbiAgICAgICAgX2NhbGxiYWNrTmFtZSgpIDogX2NhbGxiYWNrTmFtZSkgfHwgKCdaZXB0bycgKyAoanNvbnBJRCsrKSksXFxuICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXFxuICAgICAgb3JpZ2luYWxDYWxsYmFjayA9IHdpbmRvd1tjYWxsYmFja05hbWVdLFxcbiAgICAgIHJlc3BvbnNlRGF0YSxcXG4gICAgICBhYm9ydCA9IGZ1bmN0aW9uKGVycm9yVHlwZSkge1xcbiAgICAgICAgJChzY3JpcHQpLnRyaWdnZXJIYW5kbGVyKCdlcnJvcicsIGVycm9yVHlwZSB8fCAnYWJvcnQnKVxcbiAgICAgIH0sXFxuICAgICAgeGhyID0geyBhYm9ydDogYWJvcnQgfSwgYWJvcnRUaW1lb3V0XFxuXFxuICAgIGlmIChkZWZlcnJlZCkgZGVmZXJyZWQucHJvbWlzZSh4aHIpXFxuXFxuICAgICQoc2NyaXB0KS5vbignbG9hZCBlcnJvcicsIGZ1bmN0aW9uKGUsIGVycm9yVHlwZSl7XFxuICAgICAgY2xlYXJUaW1lb3V0KGFib3J0VGltZW91dClcXG4gICAgICAkKHNjcmlwdCkub2ZmKCkucmVtb3ZlKClcXG5cXG4gICAgICBpZiAoZS50eXBlID09ICdlcnJvcicgfHwgIXJlc3BvbnNlRGF0YSkge1xcbiAgICAgICAgYWpheEVycm9yKG51bGwsIGVycm9yVHlwZSB8fCAnZXJyb3InLCB4aHIsIG9wdGlvbnMsIGRlZmVycmVkKVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBhamF4U3VjY2VzcyhyZXNwb25zZURhdGFbMF0sIHhociwgb3B0aW9ucywgZGVmZXJyZWQpXFxuICAgICAgfVxcblxcbiAgICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gb3JpZ2luYWxDYWxsYmFja1xcbiAgICAgIGlmIChyZXNwb25zZURhdGEgJiYgJC5pc0Z1bmN0aW9uKG9yaWdpbmFsQ2FsbGJhY2spKVxcbiAgICAgICAgb3JpZ2luYWxDYWxsYmFjayhyZXNwb25zZURhdGFbMF0pXFxuXFxuICAgICAgb3JpZ2luYWxDYWxsYmFjayA9IHJlc3BvbnNlRGF0YSA9IHVuZGVmaW5lZFxcbiAgICB9KVxcblxcbiAgICBpZiAoYWpheEJlZm9yZVNlbmQoeGhyLCBvcHRpb25zKSA9PT0gZmFsc2UpIHtcXG4gICAgICBhYm9ydCgnYWJvcnQnKVxcbiAgICAgIHJldHVybiB4aHJcXG4gICAgfVxcblxcbiAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKCl7XFxuICAgICAgcmVzcG9uc2VEYXRhID0gYXJndW1lbnRzXFxuICAgIH1cXG5cXG4gICAgc2NyaXB0LnNyYyA9IG9wdGlvbnMudXJsLnJlcGxhY2UoL1xcXFw/KC4rKT1cXFxcPy8sICc/JDE9JyArIGNhbGxiYWNrTmFtZSlcXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpXFxuXFxuICAgIGlmIChvcHRpb25zLnRpbWVvdXQgPiAwKSBhYm9ydFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XFxuICAgICAgYWJvcnQoJ3RpbWVvdXQnKVxcbiAgICB9LCBvcHRpb25zLnRpbWVvdXQpXFxuXFxuICAgIHJldHVybiB4aHJcXG4gIH1cXG5cXG4gICQuYWpheFNldHRpbmdzID0ge1xcbiAgICAvLyBEZWZhdWx0IHR5cGUgb2YgcmVxdWVzdFxcbiAgICB0eXBlOiAnR0VUJyxcXG4gICAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBiZWZvcmUgcmVxdWVzdFxcbiAgICBiZWZvcmVTZW5kOiBlbXB0eSxcXG4gICAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBpZiB0aGUgcmVxdWVzdCBzdWNjZWVkc1xcbiAgICBzdWNjZXNzOiBlbXB0eSxcXG4gICAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCB0aGUgdGhlIHNlcnZlciBkcm9wcyBlcnJvclxcbiAgICBlcnJvcjogZW1wdHksXFxuICAgIC8vIENhbGxiYWNrIHRoYXQgaXMgZXhlY3V0ZWQgb24gcmVxdWVzdCBjb21wbGV0ZSAoYm90aDogZXJyb3IgYW5kIHN1Y2Nlc3MpXFxuICAgIGNvbXBsZXRlOiBlbXB0eSxcXG4gICAgLy8gVGhlIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3NcXG4gICAgY29udGV4dDogbnVsbCxcXG4gICAgLy8gV2hldGhlciB0byB0cmlnZ2VyIFxcXCJnbG9iYWxcXFwiIEFqYXggZXZlbnRzXFxuICAgIGdsb2JhbDogdHJ1ZSxcXG4gICAgLy8gVHJhbnNwb3J0XFxuICAgIHhocjogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KClcXG4gICAgfSxcXG4gICAgLy8gTUlNRSB0eXBlcyBtYXBwaW5nXFxuICAgIC8vIElJUyByZXR1cm5zIEphdmFzY3JpcHQgYXMgXFxcImFwcGxpY2F0aW9uL3gtamF2YXNjcmlwdFxcXCJcXG4gICAgYWNjZXB0czoge1xcbiAgICAgIHNjcmlwdDogJ3RleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24veC1qYXZhc2NyaXB0JyxcXG4gICAgICBqc29uOiAgIGpzb25UeXBlLFxcbiAgICAgIHhtbDogICAgJ2FwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwnLFxcbiAgICAgIGh0bWw6ICAgaHRtbFR5cGUsXFxuICAgICAgdGV4dDogICAndGV4dC9wbGFpbidcXG4gICAgfSxcXG4gICAgLy8gV2hldGhlciB0aGUgcmVxdWVzdCBpcyB0byBhbm90aGVyIGRvbWFpblxcbiAgICBjcm9zc0RvbWFpbjogZmFsc2UsXFxuICAgIC8vIERlZmF1bHQgdGltZW91dFxcbiAgICB0aW1lb3V0OiAwLFxcbiAgICAvLyBXaGV0aGVyIGRhdGEgc2hvdWxkIGJlIHNlcmlhbGl6ZWQgdG8gc3RyaW5nXFxuICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxcbiAgICAvLyBXaGV0aGVyIHRoZSBicm93c2VyIHNob3VsZCBiZSBhbGxvd2VkIHRvIGNhY2hlIEdFVCByZXNwb25zZXNcXG4gICAgY2FjaGU6IHRydWUsXFxuICAgIC8vVXNlZCB0byBoYW5kbGUgdGhlIHJhdyByZXNwb25zZSBkYXRhIG9mIFhNTEh0dHBSZXF1ZXN0LlxcbiAgICAvL1RoaXMgaXMgYSBwcmUtZmlsdGVyaW5nIGZ1bmN0aW9uIHRvIHNhbml0aXplIHRoZSByZXNwb25zZS5cXG4gICAgLy9UaGUgc2FuaXRpemVkIHJlc3BvbnNlIHNob3VsZCBiZSByZXR1cm5lZFxcbiAgICBkYXRhRmlsdGVyOiBlbXB0eVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gbWltZVRvRGF0YVR5cGUobWltZSkge1xcbiAgICBpZiAobWltZSkgbWltZSA9IG1pbWUuc3BsaXQoJzsnLCAyKVswXVxcbiAgICByZXR1cm4gbWltZSAmJiAoIG1pbWUgPT0gaHRtbFR5cGUgPyAnaHRtbCcgOlxcbiAgICAgIG1pbWUgPT0ganNvblR5cGUgPyAnanNvbicgOlxcbiAgICAgIHNjcmlwdFR5cGVSRS50ZXN0KG1pbWUpID8gJ3NjcmlwdCcgOlxcbiAgICAgIHhtbFR5cGVSRS50ZXN0KG1pbWUpICYmICd4bWwnICkgfHwgJ3RleHQnXFxuICB9XFxuXFxuICBmdW5jdGlvbiBhcHBlbmRRdWVyeSh1cmwsIHF1ZXJ5KSB7XFxuICAgIGlmIChxdWVyeSA9PSAnJykgcmV0dXJuIHVybFxcbiAgICByZXR1cm4gKHVybCArICcmJyArIHF1ZXJ5KS5yZXBsYWNlKC9bJj9dezEsMn0vLCAnPycpXFxuICB9XFxuXFxuICAvLyBzZXJpYWxpemUgcGF5bG9hZCBhbmQgYXBwZW5kIGl0IHRvIHRoZSBVUkwgZm9yIEdFVCByZXF1ZXN0c1xcbiAgZnVuY3Rpb24gc2VyaWFsaXplRGF0YShvcHRpb25zKSB7XFxuICAgIGlmIChvcHRpb25zLnByb2Nlc3NEYXRhICYmIG9wdGlvbnMuZGF0YSAmJiAkLnR5cGUob3B0aW9ucy5kYXRhKSAhPSBcXFwic3RyaW5nXFxcIilcXG4gICAgICBvcHRpb25zLmRhdGEgPSAkLnBhcmFtKG9wdGlvbnMuZGF0YSwgb3B0aW9ucy50cmFkaXRpb25hbClcXG4gICAgaWYgKG9wdGlvbnMuZGF0YSAmJiAoIW9wdGlvbnMudHlwZSB8fCBvcHRpb25zLnR5cGUudG9VcHBlckNhc2UoKSA9PSAnR0VUJyB8fCAnanNvbnAnID09IG9wdGlvbnMuZGF0YVR5cGUpKVxcbiAgICAgIG9wdGlvbnMudXJsID0gYXBwZW5kUXVlcnkob3B0aW9ucy51cmwsIG9wdGlvbnMuZGF0YSksIG9wdGlvbnMuZGF0YSA9IHVuZGVmaW5lZFxcbiAgfVxcblxcbiAgJC5hamF4ID0gZnVuY3Rpb24ob3B0aW9ucyl7XFxuICAgIHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zIHx8IHt9KSxcXG4gICAgICAgIGRlZmVycmVkID0gJC5EZWZlcnJlZCAmJiAkLkRlZmVycmVkKCksXFxuICAgICAgICB1cmxBbmNob3IsIGhhc2hJbmRleFxcbiAgICBmb3IgKGtleSBpbiAkLmFqYXhTZXR0aW5ncykgaWYgKHNldHRpbmdzW2tleV0gPT09IHVuZGVmaW5lZCkgc2V0dGluZ3Nba2V5XSA9ICQuYWpheFNldHRpbmdzW2tleV1cXG5cXG4gICAgYWpheFN0YXJ0KHNldHRpbmdzKVxcblxcbiAgICBpZiAoIXNldHRpbmdzLmNyb3NzRG9tYWluKSB7XFxuICAgICAgdXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXFxuICAgICAgdXJsQW5jaG9yLmhyZWYgPSBzZXR0aW5ncy51cmxcXG4gICAgICAvLyBjbGVhbnMgdXAgVVJMIGZvciAuaHJlZiAoSUUgb25seSksIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFkcm9iYnkvemVwdG8vcHVsbC8xMDQ5XFxuICAgICAgdXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZlxcbiAgICAgIHNldHRpbmdzLmNyb3NzRG9tYWluID0gKG9yaWdpbkFuY2hvci5wcm90b2NvbCArICcvLycgKyBvcmlnaW5BbmNob3IuaG9zdCkgIT09ICh1cmxBbmNob3IucHJvdG9jb2wgKyAnLy8nICsgdXJsQW5jaG9yLmhvc3QpXFxuICAgIH1cXG5cXG4gICAgaWYgKCFzZXR0aW5ncy51cmwpIHNldHRpbmdzLnVybCA9IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpXFxuICAgIGlmICgoaGFzaEluZGV4ID0gc2V0dGluZ3MudXJsLmluZGV4T2YoJyMnKSkgPiAtMSkgc2V0dGluZ3MudXJsID0gc2V0dGluZ3MudXJsLnNsaWNlKDAsIGhhc2hJbmRleClcXG4gICAgc2VyaWFsaXplRGF0YShzZXR0aW5ncylcXG5cXG4gICAgdmFyIGRhdGFUeXBlID0gc2V0dGluZ3MuZGF0YVR5cGUsIGhhc1BsYWNlaG9sZGVyID0gL1xcXFw/Lis9XFxcXD8vLnRlc3Qoc2V0dGluZ3MudXJsKVxcbiAgICBpZiAoaGFzUGxhY2Vob2xkZXIpIGRhdGFUeXBlID0gJ2pzb25wJ1xcblxcbiAgICBpZiAoc2V0dGluZ3MuY2FjaGUgPT09IGZhbHNlIHx8IChcXG4gICAgICAgICAoIW9wdGlvbnMgfHwgb3B0aW9ucy5jYWNoZSAhPT0gdHJ1ZSkgJiZcXG4gICAgICAgICAoJ3NjcmlwdCcgPT0gZGF0YVR5cGUgfHwgJ2pzb25wJyA9PSBkYXRhVHlwZSlcXG4gICAgICAgICkpXFxuICAgICAgc2V0dGluZ3MudXJsID0gYXBwZW5kUXVlcnkoc2V0dGluZ3MudXJsLCAnXz0nICsgRGF0ZS5ub3coKSlcXG5cXG4gICAgaWYgKCdqc29ucCcgPT0gZGF0YVR5cGUpIHtcXG4gICAgICBpZiAoIWhhc1BsYWNlaG9sZGVyKVxcbiAgICAgICAgc2V0dGluZ3MudXJsID0gYXBwZW5kUXVlcnkoc2V0dGluZ3MudXJsLFxcbiAgICAgICAgICBzZXR0aW5ncy5qc29ucCA/IChzZXR0aW5ncy5qc29ucCArICc9PycpIDogc2V0dGluZ3MuanNvbnAgPT09IGZhbHNlID8gJycgOiAnY2FsbGJhY2s9PycpXFxuICAgICAgcmV0dXJuICQuYWpheEpTT05QKHNldHRpbmdzLCBkZWZlcnJlZClcXG4gICAgfVxcblxcbiAgICB2YXIgbWltZSA9IHNldHRpbmdzLmFjY2VwdHNbZGF0YVR5cGVdLFxcbiAgICAgICAgaGVhZGVycyA9IHsgfSxcXG4gICAgICAgIHNldEhlYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7IGhlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IFtuYW1lLCB2YWx1ZV0gfSxcXG4gICAgICAgIHByb3RvY29sID0gL14oW1xcXFx3LV0rOilcXFxcL1xcXFwvLy50ZXN0KHNldHRpbmdzLnVybCkgPyBSZWdFeHAuJDEgOiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wsXFxuICAgICAgICB4aHIgPSBzZXR0aW5ncy54aHIoKSxcXG4gICAgICAgIG5hdGl2ZVNldEhlYWRlciA9IHhoci5zZXRSZXF1ZXN0SGVhZGVyLFxcbiAgICAgICAgYWJvcnRUaW1lb3V0XFxuXFxuICAgIGlmIChkZWZlcnJlZCkgZGVmZXJyZWQucHJvbWlzZSh4aHIpXFxuXFxuICAgIGlmICghc2V0dGluZ3MuY3Jvc3NEb21haW4pIHNldEhlYWRlcignWC1SZXF1ZXN0ZWQtV2l0aCcsICdYTUxIdHRwUmVxdWVzdCcpXFxuICAgIHNldEhlYWRlcignQWNjZXB0JywgbWltZSB8fCAnKi8qJylcXG4gICAgaWYgKG1pbWUgPSBzZXR0aW5ncy5taW1lVHlwZSB8fCBtaW1lKSB7XFxuICAgICAgaWYgKG1pbWUuaW5kZXhPZignLCcpID4gLTEpIG1pbWUgPSBtaW1lLnNwbGl0KCcsJywgMilbMF1cXG4gICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZShtaW1lKVxcbiAgICB9XFxuICAgIGlmIChzZXR0aW5ncy5jb250ZW50VHlwZSB8fCAoc2V0dGluZ3MuY29udGVudFR5cGUgIT09IGZhbHNlICYmIHNldHRpbmdzLmRhdGEgJiYgc2V0dGluZ3MudHlwZS50b1VwcGVyQ2FzZSgpICE9ICdHRVQnKSlcXG4gICAgICBzZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIHNldHRpbmdzLmNvbnRlbnRUeXBlIHx8ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKVxcblxcbiAgICBpZiAoc2V0dGluZ3MuaGVhZGVycykgZm9yIChuYW1lIGluIHNldHRpbmdzLmhlYWRlcnMpIHNldEhlYWRlcihuYW1lLCBzZXR0aW5ncy5oZWFkZXJzW25hbWVdKVxcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlciA9IHNldEhlYWRlclxcblxcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcXG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5XFxuICAgICAgICBjbGVhclRpbWVvdXQoYWJvcnRUaW1lb3V0KVxcbiAgICAgICAgdmFyIHJlc3VsdCwgZXJyb3IgPSBmYWxzZVxcbiAgICAgICAgaWYgKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09IDMwNCB8fCAoeGhyLnN0YXR1cyA9PSAwICYmIHByb3RvY29sID09ICdmaWxlOicpKSB7XFxuICAgICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUgfHwgbWltZVRvRGF0YVR5cGUoc2V0dGluZ3MubWltZVR5cGUgfHwgeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKSlcXG5cXG4gICAgICAgICAgaWYgKHhoci5yZXNwb25zZVR5cGUgPT0gJ2FycmF5YnVmZmVyJyB8fCB4aHIucmVzcG9uc2VUeXBlID09ICdibG9iJylcXG4gICAgICAgICAgICByZXN1bHQgPSB4aHIucmVzcG9uc2VcXG4gICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0geGhyLnJlc3BvbnNlVGV4dFxcblxcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9nbG9iYWwtZXZhbC13aGF0LWFyZS10aGUtb3B0aW9ucy9cXG4gICAgICAgICAgICAgIC8vIHNhbml0aXplIHJlc3BvbnNlIGFjY29yZGluZ2x5IGlmIGRhdGEgZmlsdGVyIGNhbGxiYWNrIHByb3ZpZGVkXFxuICAgICAgICAgICAgICByZXN1bHQgPSBhamF4RGF0YUZpbHRlcihyZXN1bHQsIGRhdGFUeXBlLCBzZXR0aW5ncylcXG4gICAgICAgICAgICAgIGlmIChkYXRhVHlwZSA9PSAnc2NyaXB0JykgICAgKDEsZXZhbCkocmVzdWx0KVxcbiAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVR5cGUgPT0gJ3htbCcpICByZXN1bHQgPSB4aHIucmVzcG9uc2VYTUxcXG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFUeXBlID09ICdqc29uJykgcmVzdWx0ID0gYmxhbmtSRS50ZXN0KHJlc3VsdCkgPyBudWxsIDogJC5wYXJzZUpTT04ocmVzdWx0KVxcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgZXJyb3IgPSBlIH1cXG5cXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBhamF4RXJyb3IoZXJyb3IsICdwYXJzZXJlcnJvcicsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFqYXhTdWNjZXNzKHJlc3VsdCwgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBhamF4RXJyb3IoeGhyLnN0YXR1c1RleHQgfHwgbnVsbCwgeGhyLnN0YXR1cyA/ICdlcnJvcicgOiAnYWJvcnQnLCB4aHIsIHNldHRpbmdzLCBkZWZlcnJlZClcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGFqYXhCZWZvcmVTZW5kKHhociwgc2V0dGluZ3MpID09PSBmYWxzZSkge1xcbiAgICAgIHhoci5hYm9ydCgpXFxuICAgICAgYWpheEVycm9yKG51bGwsICdhYm9ydCcsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKVxcbiAgICAgIHJldHVybiB4aHJcXG4gICAgfVxcblxcbiAgICB2YXIgYXN5bmMgPSAnYXN5bmMnIGluIHNldHRpbmdzID8gc2V0dGluZ3MuYXN5bmMgOiB0cnVlXFxuICAgIHhoci5vcGVuKHNldHRpbmdzLnR5cGUsIHNldHRpbmdzLnVybCwgYXN5bmMsIHNldHRpbmdzLnVzZXJuYW1lLCBzZXR0aW5ncy5wYXNzd29yZClcXG5cXG4gICAgaWYgKHNldHRpbmdzLnhockZpZWxkcykgZm9yIChuYW1lIGluIHNldHRpbmdzLnhockZpZWxkcykgeGhyW25hbWVdID0gc2V0dGluZ3MueGhyRmllbGRzW25hbWVdXFxuXFxuICAgIGZvciAobmFtZSBpbiBoZWFkZXJzKSBuYXRpdmVTZXRIZWFkZXIuYXBwbHkoeGhyLCBoZWFkZXJzW25hbWVdKVxcblxcbiAgICBpZiAoc2V0dGluZ3MudGltZW91dCA+IDApIGFib3J0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eVxcbiAgICAgICAgeGhyLmFib3J0KClcXG4gICAgICAgIGFqYXhFcnJvcihudWxsLCAndGltZW91dCcsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKVxcbiAgICAgIH0sIHNldHRpbmdzLnRpbWVvdXQpXFxuXFxuICAgIC8vIGF2b2lkIHNlbmRpbmcgZW1wdHkgc3RyaW5nICgjMzE5KVxcbiAgICB4aHIuc2VuZChzZXR0aW5ncy5kYXRhID8gc2V0dGluZ3MuZGF0YSA6IG51bGwpXFxuICAgIHJldHVybiB4aHJcXG4gIH1cXG5cXG4gIC8vIGhhbmRsZSBvcHRpb25hbCBkYXRhL3N1Y2Nlc3MgYXJndW1lbnRzXFxuICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cyh1cmwsIGRhdGEsIHN1Y2Nlc3MsIGRhdGFUeXBlKSB7XFxuICAgIGlmICgkLmlzRnVuY3Rpb24oZGF0YSkpIGRhdGFUeXBlID0gc3VjY2Vzcywgc3VjY2VzcyA9IGRhdGEsIGRhdGEgPSB1bmRlZmluZWRcXG4gICAgaWYgKCEkLmlzRnVuY3Rpb24oc3VjY2VzcykpIGRhdGFUeXBlID0gc3VjY2Vzcywgc3VjY2VzcyA9IHVuZGVmaW5lZFxcbiAgICByZXR1cm4ge1xcbiAgICAgIHVybDogdXJsXFxuICAgICwgZGF0YTogZGF0YVxcbiAgICAsIHN1Y2Nlc3M6IHN1Y2Nlc3NcXG4gICAgLCBkYXRhVHlwZTogZGF0YVR5cGVcXG4gICAgfVxcbiAgfVxcblxcbiAgJC5nZXQgPSBmdW5jdGlvbigvKiB1cmwsIGRhdGEsIHN1Y2Nlc3MsIGRhdGFUeXBlICovKXtcXG4gICAgcmV0dXJuICQuYWpheChwYXJzZUFyZ3VtZW50cy5hcHBseShudWxsLCBhcmd1bWVudHMpKVxcbiAgfVxcblxcbiAgJC5wb3N0ID0gZnVuY3Rpb24oLyogdXJsLCBkYXRhLCBzdWNjZXNzLCBkYXRhVHlwZSAqLyl7XFxuICAgIHZhciBvcHRpb25zID0gcGFyc2VBcmd1bWVudHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxcbiAgICBvcHRpb25zLnR5cGUgPSAnUE9TVCdcXG4gICAgcmV0dXJuICQuYWpheChvcHRpb25zKVxcbiAgfVxcblxcbiAgJC5nZXRKU09OID0gZnVuY3Rpb24oLyogdXJsLCBkYXRhLCBzdWNjZXNzICovKXtcXG4gICAgdmFyIG9wdGlvbnMgPSBwYXJzZUFyZ3VtZW50cy5hcHBseShudWxsLCBhcmd1bWVudHMpXFxuICAgIG9wdGlvbnMuZGF0YVR5cGUgPSAnanNvbidcXG4gICAgcmV0dXJuICQuYWpheChvcHRpb25zKVxcbiAgfVxcblxcbiAgJC5mbi5sb2FkID0gZnVuY3Rpb24odXJsLCBkYXRhLCBzdWNjZXNzKXtcXG4gICAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuIHRoaXNcXG4gICAgdmFyIHNlbGYgPSB0aGlzLCBwYXJ0cyA9IHVybC5zcGxpdCgvXFxcXHMvKSwgc2VsZWN0b3IsXFxuICAgICAgICBvcHRpb25zID0gcGFyc2VBcmd1bWVudHModXJsLCBkYXRhLCBzdWNjZXNzKSxcXG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucy5zdWNjZXNzXFxuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSBvcHRpb25zLnVybCA9IHBhcnRzWzBdLCBzZWxlY3RvciA9IHBhcnRzWzFdXFxuICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3BvbnNlKXtcXG4gICAgICBzZWxmLmh0bWwoc2VsZWN0b3IgP1xcbiAgICAgICAgJCgnPGRpdj4nKS5odG1sKHJlc3BvbnNlLnJlcGxhY2UocnNjcmlwdCwgXFxcIlxcXCIpKS5maW5kKHNlbGVjdG9yKVxcbiAgICAgICAgOiByZXNwb25zZSlcXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5hcHBseShzZWxmLCBhcmd1bWVudHMpXFxuICAgIH1cXG4gICAgJC5hamF4KG9wdGlvbnMpXFxuICAgIHJldHVybiB0aGlzXFxuICB9XFxuXFxuICB2YXIgZXNjYXBlID0gZW5jb2RlVVJJQ29tcG9uZW50XFxuXFxuICBmdW5jdGlvbiBzZXJpYWxpemUocGFyYW1zLCBvYmosIHRyYWRpdGlvbmFsLCBzY29wZSl7XFxuICAgIHZhciB0eXBlLCBhcnJheSA9ICQuaXNBcnJheShvYmopLCBoYXNoID0gJC5pc1BsYWluT2JqZWN0KG9iailcXG4gICAgJC5lYWNoKG9iaiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgIHR5cGUgPSAkLnR5cGUodmFsdWUpXFxuICAgICAgaWYgKHNjb3BlKSBrZXkgPSB0cmFkaXRpb25hbCA/IHNjb3BlIDpcXG4gICAgICAgIHNjb3BlICsgJ1snICsgKGhhc2ggfHwgdHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdhcnJheScgPyBrZXkgOiAnJykgKyAnXSdcXG4gICAgICAvLyBoYW5kbGUgZGF0YSBpbiBzZXJpYWxpemVBcnJheSgpIGZvcm1hdFxcbiAgICAgIGlmICghc2NvcGUgJiYgYXJyYXkpIHBhcmFtcy5hZGQodmFsdWUubmFtZSwgdmFsdWUudmFsdWUpXFxuICAgICAgLy8gcmVjdXJzZSBpbnRvIG5lc3RlZCBvYmplY3RzXFxuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcXFwiYXJyYXlcXFwiIHx8ICghdHJhZGl0aW9uYWwgJiYgdHlwZSA9PSBcXFwib2JqZWN0XFxcIikpXFxuICAgICAgICBzZXJpYWxpemUocGFyYW1zLCB2YWx1ZSwgdHJhZGl0aW9uYWwsIGtleSlcXG4gICAgICBlbHNlIHBhcmFtcy5hZGQoa2V5LCB2YWx1ZSlcXG4gICAgfSlcXG4gIH1cXG5cXG4gICQucGFyYW0gPSBmdW5jdGlvbihvYmosIHRyYWRpdGlvbmFsKXtcXG4gICAgdmFyIHBhcmFtcyA9IFtdXFxuICAgIHBhcmFtcy5hZGQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XFxuICAgICAgaWYgKCQuaXNGdW5jdGlvbih2YWx1ZSkpIHZhbHVlID0gdmFsdWUoKVxcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB2YWx1ZSA9IFxcXCJcXFwiXFxuICAgICAgdGhpcy5wdXNoKGVzY2FwZShrZXkpICsgJz0nICsgZXNjYXBlKHZhbHVlKSlcXG4gICAgfVxcbiAgICBzZXJpYWxpemUocGFyYW1zLCBvYmosIHRyYWRpdGlvbmFsKVxcbiAgICByZXR1cm4gcGFyYW1zLmpvaW4oJyYnKS5yZXBsYWNlKC8lMjAvZywgJysnKVxcbiAgfVxcbn0pKFplcHRvKVxcblxcbjsoZnVuY3Rpb24oJCl7XFxuICAkLmZuLnNlcmlhbGl6ZUFycmF5ID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBuYW1lLCB0eXBlLCByZXN1bHQgPSBbXSxcXG4gICAgICBhZGQgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgICAgaWYgKHZhbHVlLmZvckVhY2gpIHJldHVybiB2YWx1ZS5mb3JFYWNoKGFkZClcXG4gICAgICAgIHJlc3VsdC5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pXFxuICAgICAgfVxcbiAgICBpZiAodGhpc1swXSkgJC5lYWNoKHRoaXNbMF0uZWxlbWVudHMsIGZ1bmN0aW9uKF8sIGZpZWxkKXtcXG4gICAgICB0eXBlID0gZmllbGQudHlwZSwgbmFtZSA9IGZpZWxkLm5hbWVcXG4gICAgICBpZiAobmFtZSAmJiBmaWVsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9ICdmaWVsZHNldCcgJiZcXG4gICAgICAgICFmaWVsZC5kaXNhYmxlZCAmJiB0eXBlICE9ICdzdWJtaXQnICYmIHR5cGUgIT0gJ3Jlc2V0JyAmJiB0eXBlICE9ICdidXR0b24nICYmIHR5cGUgIT0gJ2ZpbGUnICYmXFxuICAgICAgICAoKHR5cGUgIT0gJ3JhZGlvJyAmJiB0eXBlICE9ICdjaGVja2JveCcpIHx8IGZpZWxkLmNoZWNrZWQpKVxcbiAgICAgICAgICBhZGQoJChmaWVsZCkudmFsKCkpXFxuICAgIH0pXFxuICAgIHJldHVybiByZXN1bHRcXG4gIH1cXG5cXG4gICQuZm4uc2VyaWFsaXplID0gZnVuY3Rpb24oKXtcXG4gICAgdmFyIHJlc3VsdCA9IFtdXFxuICAgIHRoaXMuc2VyaWFsaXplQXJyYXkoKS5mb3JFYWNoKGZ1bmN0aW9uKGVsbSl7XFxuICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGVsbS5uYW1lKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChlbG0udmFsdWUpKVxcbiAgICB9KVxcbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyYnKVxcbiAgfVxcblxcbiAgJC5mbi5zdWJtaXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xcbiAgICBpZiAoMCBpbiBhcmd1bWVudHMpIHRoaXMuYmluZCgnc3VibWl0JywgY2FsbGJhY2spXFxuICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoKSB7XFxuICAgICAgdmFyIGV2ZW50ID0gJC5FdmVudCgnc3VibWl0JylcXG4gICAgICB0aGlzLmVxKDApLnRyaWdnZXIoZXZlbnQpXFxuICAgICAgaWYgKCFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgdGhpcy5nZXQoMCkuc3VibWl0KClcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpc1xcbiAgfVxcblxcbn0pKFplcHRvKVxcblxcbjsoZnVuY3Rpb24oKXtcXG4gIC8vIGdldENvbXB1dGVkU3R5bGUgc2hvdWxkbid0IGZyZWFrIG91dCB3aGVuIGNhbGxlZFxcbiAgLy8gd2l0aG91dCBhIHZhbGlkIGVsZW1lbnQgYXMgYXJndW1lbnRcXG4gIHRyeSB7XFxuICAgIGdldENvbXB1dGVkU3R5bGUodW5kZWZpbmVkKVxcbiAgfSBjYXRjaChlKSB7XFxuICAgIHZhciBuYXRpdmVHZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZVxcbiAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHBzZXVkb0VsZW1lbnQpe1xcbiAgICAgIHRyeSB7XFxuICAgICAgICByZXR1cm4gbmF0aXZlR2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBwc2V1ZG9FbGVtZW50KVxcbiAgICAgIH0gY2F0Y2goZSkge1xcbiAgICAgICAgcmV0dXJuIG51bGxcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59KSgpXFxuICByZXR1cm4gWmVwdG9cXG59KSlcXG5cIiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n")},,,function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = __webpack_require__(10);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvX2FydC10ZW1wbGF0ZUA0LjEzLjJAYXJ0LXRlbXBsYXRlL2xpYi9ydW50aW1lLmpzPzFkNTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tcGlsZS9ydW50aW1lJyk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {\n\n/*! art-template@runtime | https://github.com/aui/art-template */\n\nvar globalThis = typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};\n\nvar runtime = Object.create(globalThis);\nvar ESCAPE_REG = /[\"&'<>]/;\n\n/**\n * \n * @param  {any}        content\n * @return {string}\n */\nruntime.$escape = function (content) {\n    return xmlEscape(toString(content));\n};\n\n/**\n * \n * @param {array|Object} data\n * @param {function}     callback\n */\nruntime.$each = function (data, callback) {\n    if (Array.isArray(data)) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            callback(data[i], i);\n        }\n    } else {\n        for (var _i in data) {\n            callback(data[_i], _i);\n        }\n    }\n};\n\n// \nfunction toString(value) {\n    if (typeof value !== 'string') {\n        if (value === undefined || value === null) {\n            value = '';\n        } else if (typeof value === 'function') {\n            value = toString(value.call(value));\n        } else {\n            value = JSON.stringify(value);\n        }\n    }\n\n    return value;\n}\n\n//  HTML \nfunction xmlEscape(content) {\n    var html = '' + content;\n    var regexResult = ESCAPE_REG.exec(html);\n    if (!regexResult) {\n        return content;\n    }\n\n    var result = '';\n    var i = void 0,\n        lastIndex = void 0,\n        char = void 0;\n    for (i = regexResult.index, lastIndex = 0; i < html.length; i++) {\n        switch (html.charCodeAt(i)) {\n            case 34:\n                char = '&#34;';\n                break;\n            case 38:\n                char = '&#38;';\n                break;\n            case 39:\n                char = '&#39;';\n                break;\n            case 60:\n                char = '&#60;';\n                break;\n            case 62:\n                char = '&#62;';\n                break;\n            default:\n                continue;\n        }\n\n        if (lastIndex !== i) {\n            result += html.substring(lastIndex, i);\n        }\n\n        lastIndex = i + 1;\n        result += char;\n    }\n\n    if (lastIndex !== i) {\n        return result + html.substring(lastIndex, i);\n    } else {\n        return result;\n    }\n}\n\nmodule.exports = runtime;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL19hcnQtdGVtcGxhdGVANC4xMy4yQGFydC10ZW1wbGF0ZS9saWIvY29tcGlsZS9ydW50aW1lLmpzPzgyZTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiEgYXJ0LXRlbXBsYXRlQHJ1bnRpbWUgfCBodHRwczovL2dpdGh1Yi5jb20vYXVpL2FydC10ZW1wbGF0ZSAqL1xuXG52YXIgZ2xvYmFsVGhpcyA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDoge307XG5cbnZhciBydW50aW1lID0gT2JqZWN0LmNyZWF0ZShnbG9iYWxUaGlzKTtcbnZhciBFU0NBUEVfUkVHID0gL1tcIiYnPD5dLztcblxuLyoqXG4gKiDnvJbnoIHmqKHmnb/ovpPlh7rnmoTlhoXlrrlcbiAqIEBwYXJhbSAge2FueX0gICAgICAgIGNvbnRlbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xucnVudGltZS4kZXNjYXBlID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICByZXR1cm4geG1sRXNjYXBlKHRvU3RyaW5nKGNvbnRlbnQpKTtcbn07XG5cbi8qKlxuICog6L+t5Luj5Zmo77yM5pSv5oyB5pWw57uE5LiO5a+56LGhXG4gKiBAcGFyYW0ge2FycmF5fE9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtmdW5jdGlvbn0gICAgIGNhbGxiYWNrXG4gKi9cbnJ1bnRpbWUuJGVhY2ggPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YVtpXSwgaSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBfaSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhW19pXSwgX2kpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8g5bCG55uu5qCH6L2s5oiQ5a2X56ymXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSB0b1N0cmluZyh2YWx1ZS5jYWxsKHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8g57yW56CBIEhUTUwg5YaF5a65XG5mdW5jdGlvbiB4bWxFc2NhcGUoY29udGVudCkge1xuICAgIHZhciBodG1sID0gJycgKyBjb250ZW50O1xuICAgIHZhciByZWdleFJlc3VsdCA9IEVTQ0FQRV9SRUcuZXhlYyhodG1sKTtcbiAgICBpZiAoIXJlZ2V4UmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgbGFzdEluZGV4ID0gdm9pZCAwLFxuICAgICAgICBjaGFyID0gdm9pZCAwO1xuICAgIGZvciAoaSA9IHJlZ2V4UmVzdWx0LmluZGV4LCBsYXN0SW5kZXggPSAwOyBpIDwgaHRtbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzd2l0Y2ggKGh0bWwuY2hhckNvZGVBdChpKSkge1xuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICBjaGFyID0gJyYjMzQ7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgICAgY2hhciA9ICcmIzM4Oyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAgIGNoYXIgPSAnJiMzOTsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICAgICAgICBjaGFyID0gJyYjNjA7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjI6XG4gICAgICAgICAgICAgICAgY2hhciA9ICcmIzYyOyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGh0bWwuc3Vic3RyaW5nKGxhc3RJbmRleCwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0SW5kZXggPSBpICsgMTtcbiAgICAgICAgcmVzdWx0ICs9IGNoYXI7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgaHRtbC5zdWJzdHJpbmcobGFzdEluZGV4LCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBydW50aW1lOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL193ZWJwYWNrQDQuMjkuNUB3ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzP2I1ODIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n!function (e, n) {\n  module.exports = n(e);\n}(window, function (e, n) {\n  function i(n, i, t) {\n    e.WeixinJSBridge ? WeixinJSBridge.invoke(n, o(i), function (e) {\n      c(n, e, t);\n    }) : u(n, t);\n  }\n  function t(n, i, t) {\n    e.WeixinJSBridge ? WeixinJSBridge.on(n, function (e) {\n      t && t.trigger && t.trigger(e), c(n, e, i);\n    }) : t ? u(n, t) : u(n, i);\n  }\n  function o(e) {\n    return e = e || {}, e.appId = C.appId, e.verifyAppId = C.appId, e.verifySignType = "sha1", e.verifyTimestamp = C.timestamp + "", e.verifyNonceStr = C.nonceStr, e.verifySignature = C.signature, e;\n  }\n  function r(e) {\n    return {\n      timeStamp: e.timestamp + "",\n      nonceStr: e.nonceStr,\n      package: e.package,\n      paySign: e.paySign,\n      signType: e.signType || "SHA1"\n    };\n  }\n  function a(e) {\n    return e.postalCode = e.addressPostalCode, delete e.addressPostalCode, e.provinceName = e.proviceFirstStageName, delete e.proviceFirstStageName, e.cityName = e.addressCitySecondStageName, delete e.addressCitySecondStageName, e.countryName = e.addressCountiesThirdStageName, delete e.addressCountiesThirdStageName, e.detailInfo = e.addressDetailInfo, delete e.addressDetailInfo, e;\n  }\n  function c(e, n, i) {\n    "openEnterpriseChat" == e && (n.errCode = n.err_code), delete n.err_code, delete n.err_desc, delete n.err_detail;\n    var t = n.errMsg;\n    t || (t = n.err_msg, delete n.err_msg, t = s(e, t), n.errMsg = t), (i = i || {})._complete && (i._complete(n), delete i._complete), t = n.errMsg || "", C.debug && !i.isInnerInvoke && alert(JSON.stringify(n));\n    var o = t.indexOf(":");\n    switch (t.substring(o + 1)) {\n      case "ok":\n        i.success && i.success(n);\n        break;\n      case "cancel":\n        i.cancel && i.cancel(n);\n        break;\n      default:\n        i.fail && i.fail(n);\n    }\n    i.complete && i.complete(n);\n  }\n  function s(e, n) {\n    var i = e,\n        t = v[i];\n    t && (i = t);\n    var o = "ok";\n    if (n) {\n      var r = n.indexOf(":");\n      "confirm" == (o = n.substring(r + 1)) && (o = "ok"), "failed" == o && (o = "fail"), -1 != o.indexOf("failed_") && (o = o.substring(7)), -1 != o.indexOf("fail_") && (o = o.substring(5)), "access denied" != (o = (o = o.replace(/_/g, " ")).toLowerCase()) && "no permission to execute" != o || (o = "permission denied"), "config" == i && "function not exist" == o && (o = "ok"), "" == o && (o = "fail");\n    }\n    return n = i + ":" + o;\n  }\n  function d(e) {\n    if (e) {\n      for (var n = 0, i = e.length; n < i; ++n) {\n        var t = e[n],\n            o = h[t];\n        o && (e[n] = o);\n      }\n      return e;\n    }\n  }\n  function u(e, n) {\n    if (!(!C.debug || n && n.isInnerInvoke)) {\n      var i = v[e];\n      i && (e = i), n && n._complete && delete n._complete, console.log(\'"\' + e + \'",\', n || "");\n    }\n  }\n  function l(e) {\n    if (!(k || w || C.debug || x < "6.0.2" || V.systemType < 0)) {\n      var n = new Image();\n      V.appId = C.appId, V.initTime = A.initEndTime - A.initStartTime, V.preVerifyTime = A.preVerifyEndTime - A.preVerifyStartTime, N.getNetworkType({\n        isInnerInvoke: !0,\n        success: function success(e) {\n          V.networkType = e.networkType;\n          var i = "https://open.weixin.qq.com/sdk/report?v=" + V.version + "&o=" + V.isPreVerifyOk + "&s=" + V.systemType + "&c=" + V.clientVersion + "&a=" + V.appId + "&n=" + V.networkType + "&i=" + V.initTime + "&p=" + V.preVerifyTime + "&u=" + V.url;\n          n.src = i;\n        }\n      });\n    }\n  }\n  function p() {\n    return new Date().getTime();\n  }\n  function f(n) {\n    T && (e.WeixinJSBridge ? n() : S.addEventListener && S.addEventListener("WeixinJSBridgeReady", n, !1));\n  }\n  function m() {\n    N.invoke || (N.invoke = function (n, i, t) {\n      e.WeixinJSBridge && WeixinJSBridge.invoke(n, o(i), t);\n    }, N.on = function (n, i) {\n      e.WeixinJSBridge && WeixinJSBridge.on(n, i);\n    });\n  }\n  function g(e) {\n    if ("string" == typeof e && e.length > 0) {\n      var n = e.split("?")[0],\n          i = e.split("?")[1];\n      return n += ".html", void 0 !== i ? n + "?" + i : n;\n    }\n  }\n  if (!e.jWeixin) {\n    var _N;\n\n    var h = {\n      config: "preVerifyJSAPI",\n      onMenuShareTimeline: "menu:share:timeline",\n      onMenuShareAppMessage: "menu:share:appmessage",\n      onMenuShareQQ: "menu:share:qq",\n      onMenuShareWeibo: "menu:share:weiboApp",\n      onMenuShareQZone: "menu:share:QZone",\n      previewImage: "imagePreview",\n      getLocation: "geoLocation",\n      openProductSpecificView: "openProductViewWithPid",\n      addCard: "batchAddCard",\n      openCard: "batchViewCard",\n      chooseWXPay: "getBrandWCPayRequest",\n      openEnterpriseRedPacket: "getRecevieBizHongBaoRequest",\n      startSearchBeacons: "startMonitoringBeacons",\n      stopSearchBeacons: "stopMonitoringBeacons",\n      onSearchBeacons: "onBeaconsInRange",\n      consumeAndShareCard: "consumedShareCard",\n      openAddress: "editAddress"\n    },\n        v = function () {\n      var e = {};\n      for (var n in h) {\n        e[h[n]] = n;\n      }return e;\n    }(),\n        S = e.document,\n        I = S.title,\n        y = navigator.userAgent.toLowerCase(),\n        _ = navigator.platform.toLowerCase(),\n        k = !(!_.match("mac") && !_.match("win")),\n        w = -1 != y.indexOf("wxdebugger"),\n        T = -1 != y.indexOf("micromessenger"),\n        M = -1 != y.indexOf("android"),\n        P = -1 != y.indexOf("iphone") || -1 != y.indexOf("ipad"),\n        x = function () {\n      var e = y.match(/micromessenger\\/(\\d+\\.\\d+\\.\\d+)/) || y.match(/micromessenger\\/(\\d+\\.\\d+)/);\n      return e ? e[1] : "";\n    }(),\n        A = {\n      initStartTime: p(),\n      initEndTime: 0,\n      preVerifyStartTime: 0,\n      preVerifyEndTime: 0\n    },\n        V = {\n      version: 1,\n      appId: "",\n      initTime: 0,\n      preVerifyTime: 0,\n      networkType: "",\n      isPreVerifyOk: 1,\n      systemType: P ? 1 : M ? 2 : -1,\n      clientVersion: x,\n      url: encodeURIComponent(location.href)\n    },\n        C = {},\n        L = {\n      _completes: []\n    },\n        B = {\n      state: 0,\n      data: {}\n    };\n    f(function () {\n      A.initEndTime = p();\n    });\n    var O = !1,\n        E = [],\n        N = (_N = {\n      config: function config(e) {\n        C = e, u("config", e);\n        var n = !1 !== C.check;\n        f(function () {\n          if (n) i(h.config, {\n            verifyJsApiList: d(C.jsApiList)\n          }, function () {\n            L._complete = function (e) {\n              A.preVerifyEndTime = p(), B.state = 1, B.data = e;\n            }, L.success = function (e) {\n              V.isPreVerifyOk = 0;\n            }, L.fail = function (e) {\n              L._fail ? L._fail(e) : B.state = -1;\n            };\n            var e = L._completes;\n            return e.push(function () {\n              l();\n            }), L.complete = function (n) {\n              for (var i = 0, t = e.length; i < t; ++i) {\n                e[i]();\n              }L._completes = [];\n            }, L;\n          }()), A.preVerifyStartTime = p();else {\n            B.state = 1;\n            for (var e = L._completes, t = 0, o = e.length; t < o; ++t) {\n              e[t]();\n            }L._completes = [];\n          }\n        }), m();\n      },\n      ready: function ready(e) {\n        0 != B.state ? e() : (L._completes.push(e), !T && C.debug && e());\n      },\n      error: function error(e) {\n        x < "6.0.2" || (-1 == B.state ? e(B.data) : L._fail = e);\n      },\n      checkJsApi: function checkJsApi(e) {\n        var n = function n(e) {\n          var n = e.checkResult;\n          for (var i in n) {\n            var t = v[i];\n            t && (n[t] = n[i], delete n[i]);\n          }\n          return e;\n        };\n        i("checkJsApi", {\n          jsApiList: d(e.jsApiList)\n        }, (e._complete = function (e) {\n          if (M) {\n            var i = e.checkResult;\n            i && (e.checkResult = JSON.parse(i));\n          }\n          e = n(e);\n        }, e));\n      },\n      onMenuShareTimeline: function onMenuShareTimeline(e) {\n        t(h.onMenuShareTimeline, {\n          complete: function complete() {\n            i("shareTimeline", {\n              title: e.title || I,\n              desc: e.title || I,\n              img_url: e.imgUrl || "",\n              link: e.link || location.href,\n              type: e.type || "link",\n              data_url: e.dataUrl || ""\n            }, e);\n          }\n        }, e);\n      },\n      onMenuShareAppMessage: function onMenuShareAppMessage(e) {\n        t(h.onMenuShareAppMessage, {\n          complete: function complete(n) {\n            "favorite" === n.scene ? i("sendAppMessage", {\n              title: e.title || I,\n              desc: e.desc || "",\n              link: e.link || location.href,\n              img_url: e.imgUrl || "",\n              type: e.type || "link",\n              data_url: e.dataUrl || ""\n            }) : i("sendAppMessage", {\n              title: e.title || I,\n              desc: e.desc || "",\n              link: e.link || location.href,\n              img_url: e.imgUrl || "",\n              type: e.type || "link",\n              data_url: e.dataUrl || ""\n            }, e);\n          }\n        }, e);\n      },\n      onMenuShareQQ: function onMenuShareQQ(e) {\n        t(h.onMenuShareQQ, {\n          complete: function complete() {\n            i("shareQQ", {\n              title: e.title || I,\n              desc: e.desc || "",\n              img_url: e.imgUrl || "",\n              link: e.link || location.href\n            }, e);\n          }\n        }, e);\n      },\n      onMenuShareWeibo: function onMenuShareWeibo(e) {\n        t(h.onMenuShareWeibo, {\n          complete: function complete() {\n            i("shareWeiboApp", {\n              title: e.title || I,\n              desc: e.desc || "",\n              img_url: e.imgUrl || "",\n              link: e.link || location.href\n            }, e);\n          }\n        }, e);\n      },\n      onMenuShareQZone: function onMenuShareQZone(e) {\n        t(h.onMenuShareQZone, {\n          complete: function complete() {\n            i("shareQZone", {\n              title: e.title || I,\n              desc: e.desc || "",\n              img_url: e.imgUrl || "",\n              link: e.link || location.href\n            }, e);\n          }\n        }, e);\n      },\n      updateTimelineShareData: function updateTimelineShareData(e) {\n        i("updateTimelineShareData", {\n          title: e.title,\n          link: e.link,\n          imgUrl: e.imgUrl\n        }, e);\n      },\n      updateAppMessageShareData: function updateAppMessageShareData(e) {\n        i("updateAppMessageShareData", {\n          title: e.title,\n          desc: e.desc,\n          link: e.link,\n          imgUrl: e.imgUrl\n        }, e);\n      },\n      startRecord: function startRecord(e) {\n        i("startRecord", {}, e);\n      },\n      stopRecord: function stopRecord(e) {\n        i("stopRecord", {}, e);\n      },\n      onVoiceRecordEnd: function onVoiceRecordEnd(e) {\n        t("onVoiceRecordEnd", e);\n      },\n      playVoice: function playVoice(e) {\n        i("playVoice", {\n          localId: e.localId\n        }, e);\n      },\n      pauseVoice: function pauseVoice(e) {\n        i("pauseVoice", {\n          localId: e.localId\n        }, e);\n      },\n      stopVoice: function stopVoice(e) {\n        i("stopVoice", {\n          localId: e.localId\n        }, e);\n      },\n      onVoicePlayEnd: function onVoicePlayEnd(e) {\n        t("onVoicePlayEnd", e);\n      },\n      uploadVoice: function uploadVoice(e) {\n        i("uploadVoice", {\n          localId: e.localId,\n          isShowProgressTips: 0 == e.isShowProgressTips ? 0 : 1\n        }, e);\n      },\n      downloadVoice: function downloadVoice(e) {\n        i("downloadVoice", {\n          serverId: e.serverId,\n          isShowProgressTips: 0 == e.isShowProgressTips ? 0 : 1\n        }, e);\n      },\n      translateVoice: function translateVoice(e) {\n        i("translateVoice", {\n          localId: e.localId,\n          isShowProgressTips: 0 == e.isShowProgressTips ? 0 : 1\n        }, e);\n      },\n      chooseImage: function chooseImage(e) {\n        i("chooseImage", {\n          scene: "1|2",\n          count: e.count || 9,\n          sizeType: e.sizeType || ["original", "compressed"],\n          sourceType: e.sourceType || ["album", "camera"]\n        }, (e._complete = function (e) {\n          if (M) {\n            var n = e.localIds;\n            try {\n              n && (e.localIds = JSON.parse(n));\n            } catch (e) {}\n          }\n        }, e));\n      },\n      getLocation: function getLocation(e) {},\n      previewImage: function previewImage(e) {\n        i(h.previewImage, {\n          current: e.current,\n          urls: e.urls\n        }, e);\n      },\n      uploadImage: function uploadImage(e) {\n        i("uploadImage", {\n          localId: e.localId,\n          isShowProgressTips: 0 == e.isShowProgressTips ? 0 : 1\n        }, e);\n      },\n      downloadImage: function downloadImage(e) {\n        i("downloadImage", {\n          serverId: e.serverId,\n          isShowProgressTips: 0 == e.isShowProgressTips ? 0 : 1\n        }, e);\n      },\n      getLocalImgData: function getLocalImgData(e) {\n        !1 === O ? (O = !0, i("getLocalImgData", {\n          localId: e.localId\n        }, (e._complete = function (e) {\n          if (O = !1, E.length > 0) {\n            var n = E.shift();\n            wx.getLocalImgData(n);\n          }\n        }, e))) : E.push(e);\n      },\n      getNetworkType: function getNetworkType(e) {\n        var n = function n(e) {\n          var n = e.errMsg;\n          e.errMsg = "getNetworkType:ok";\n          var i = e.subtype;\n          if (delete e.subtype, i) e.networkType = i;else {\n            var t = n.indexOf(":"),\n                o = n.substring(t + 1);\n            switch (o) {\n              case "wifi":\n              case "edge":\n              case "wwan":\n                e.networkType = o;\n                break;\n              default:\n                e.errMsg = "getNetworkType:fail";\n            }\n          }\n          return e;\n        };\n        i("getNetworkType", {}, (e._complete = function (e) {\n          e = n(e);\n        }, e));\n      },\n      openLocation: function openLocation(e) {\n        i("openLocation", {\n          latitude: e.latitude,\n          longitude: e.longitude,\n          name: e.name || "",\n          address: e.address || "",\n          scale: e.scale || 28,\n          infoUrl: e.infoUrl || ""\n        }, e);\n      }\n    }, _defineProperty(_N, "getLocation", function getLocation(e) {\n      e = e || {}, i(h.getLocation, {\n        type: e.type || "wgs84"\n      }, (e._complete = function (e) {\n        delete e.type;\n      }, e));\n    }), _defineProperty(_N, "hideOptionMenu", function hideOptionMenu(e) {\n      i("hideOptionMenu", {}, e);\n    }), _defineProperty(_N, "showOptionMenu", function showOptionMenu(e) {\n      i("showOptionMenu", {}, e);\n    }), _defineProperty(_N, "closeWindow", function closeWindow(e) {\n      i("closeWindow", {}, e = e || {});\n    }), _defineProperty(_N, "hideMenuItems", function hideMenuItems(e) {\n      i("hideMenuItems", {\n        menuList: e.menuList\n      }, e);\n    }), _defineProperty(_N, "showMenuItems", function showMenuItems(e) {\n      i("showMenuItems", {\n        menuList: e.menuList\n      }, e);\n    }), _defineProperty(_N, "hideAllNonBaseMenuItem", function hideAllNonBaseMenuItem(e) {\n      i("hideAllNonBaseMenuItem", {}, e);\n    }), _defineProperty(_N, "showAllNonBaseMenuItem", function showAllNonBaseMenuItem(e) {\n      i("showAllNonBaseMenuItem", {}, e);\n    }), _defineProperty(_N, "scanQRCode", function scanQRCode(e) {\n      i("scanQRCode", {\n        needResult: (e = e || {}).needResult || 0,\n        scanType: e.scanType || ["qrCode", "barCode"]\n      }, (e._complete = function (e) {\n        if (P) {\n          var n = e.resultStr;\n          if (n) {\n            var i = JSON.parse(n);\n            e.resultStr = i && i.scan_code && i.scan_code.scan_result;\n          }\n        }\n      }, e));\n    }), _defineProperty(_N, "openAddress", function openAddress(e) {\n      i(h.openAddress, {}, (e._complete = function (e) {\n        e = a(e);\n      }, e));\n    }), _defineProperty(_N, "openProductSpecificView", function openProductSpecificView(e) {\n      i(h.openProductSpecificView, {\n        pid: e.productId,\n        view_type: e.viewType || 0,\n        ext_info: e.extInfo\n      }, e);\n    }), _defineProperty(_N, "addCard", function addCard(e) {\n      for (var n = e.cardList, t = [], o = 0, r = n.length; o < r; ++o) {\n        var a = n[o],\n            c = {\n          card_id: a.cardId,\n          card_ext: a.cardExt\n        };\n        t.push(c);\n      }\n      i(h.addCard, {\n        card_list: t\n      }, (e._complete = function (e) {\n        var n = e.card_list;\n        if (n) {\n          for (var i = 0, t = (n = JSON.parse(n)).length; i < t; ++i) {\n            var o = n[i];\n            o.cardId = o.card_id, o.cardExt = o.card_ext, o.isSuccess = !!o.is_succ, delete o.card_id, delete o.card_ext, delete o.is_succ;\n          }\n          e.cardList = n, delete e.card_list;\n        }\n      }, e));\n    }), _defineProperty(_N, "chooseCard", function chooseCard(e) {\n      i("chooseCard", {\n        app_id: C.appId,\n        location_id: e.shopId || "",\n        sign_type: e.signType || "SHA1",\n        card_id: e.cardId || "",\n        card_type: e.cardType || "",\n        card_sign: e.cardSign,\n        time_stamp: e.timestamp + "",\n        nonce_str: e.nonceStr\n      }, (e._complete = function (e) {\n        e.cardList = e.choose_card_info, delete e.choose_card_info;\n      }, e));\n    }), _defineProperty(_N, "openCard", function openCard(e) {\n      for (var n = e.cardList, t = [], o = 0, r = n.length; o < r; ++o) {\n        var a = n[o],\n            c = {\n          card_id: a.cardId,\n          code: a.code\n        };\n        t.push(c);\n      }\n      i(h.openCard, {\n        card_list: t\n      }, e);\n    }), _defineProperty(_N, "consumeAndShareCard", function consumeAndShareCard(e) {\n      i(h.consumeAndShareCard, {\n        consumedCardId: e.cardId,\n        consumedCode: e.code\n      }, e);\n    }), _defineProperty(_N, "chooseWXPay", function chooseWXPay(e) {\n      i(h.chooseWXPay, r(e), e);\n    }), _defineProperty(_N, "openEnterpriseRedPacket", function openEnterpriseRedPacket(e) {\n      i(h.openEnterpriseRedPacket, r(e), e);\n    }), _defineProperty(_N, "startSearchBeacons", function startSearchBeacons(e) {\n      i(h.startSearchBeacons, {\n        ticket: e.ticket\n      }, e);\n    }), _defineProperty(_N, "stopSearchBeacons", function stopSearchBeacons(e) {\n      i(h.stopSearchBeacons, {}, e);\n    }), _defineProperty(_N, "onSearchBeacons", function onSearchBeacons(e) {\n      t(h.onSearchBeacons, e);\n    }), _defineProperty(_N, "openEnterpriseChat", function openEnterpriseChat(e) {\n      i("openEnterpriseChat", {\n        useridlist: e.userIds,\n        chatname: e.groupName\n      }, e);\n    }), _defineProperty(_N, "launchMiniProgram", function launchMiniProgram(e) {\n      i("launchMiniProgram", {\n        targetAppId: e.targetAppId,\n        path: g(e.path),\n        envVersion: e.envVersion\n      }, e);\n    }), _defineProperty(_N, "miniProgram", {\n      navigateBack: function navigateBack(e) {\n        e = e || {}, f(function () {\n          i("invokeMiniProgramAPI", {\n            name: "navigateBack",\n            arg: {\n              delta: e.delta || 1\n            }\n          }, e);\n        });\n      },\n      navigateTo: function navigateTo(e) {\n        f(function () {\n          i("invokeMiniProgramAPI", {\n            name: "navigateTo",\n            arg: {\n              url: e.url\n            }\n          }, e);\n        });\n      },\n      redirectTo: function redirectTo(e) {\n        f(function () {\n          i("invokeMiniProgramAPI", {\n            name: "redirectTo",\n            arg: {\n              url: e.url\n            }\n          }, e);\n        });\n      },\n      switchTab: function switchTab(e) {\n        f(function () {\n          i("invokeMiniProgramAPI", {\n            name: "switchTab",\n            arg: {\n              url: e.url\n            }\n          }, e);\n        });\n      },\n      reLaunch: function reLaunch(e) {\n        f(function () {\n          i("invokeMiniProgramAPI", {\n            name: "reLaunch",\n            arg: {\n              url: e.url\n            }\n          }, e);\n        });\n      },\n      postMessage: function postMessage(e) {\n        f(function () {\n          i("invokeMiniProgramAPI", {\n            name: "postMessage",\n            arg: e.data || {}\n          }, e);\n        });\n      },\n      getEnv: function getEnv(n) {\n        f(function () {\n          n({\n            miniprogram: "miniprogram" === e.__wxjs_environment\n          });\n        });\n      }\n    }), _N),\n        b = 1,\n        R = {};\n    return S.addEventListener("error", function (e) {\n      if (!M) {\n        var n = e.target,\n            i = n.tagName,\n            t = n.src;\n        if (("IMG" == i || "VIDEO" == i || "AUDIO" == i || "SOURCE" == i) && -1 != t.indexOf("wxlocalresource://")) {\n          e.preventDefault(), e.stopPropagation();\n          var o = n["wx-id"];\n          if (o || (o = b++, n["wx-id"] = o), R[o]) return;\n          R[o] = !0, wx.ready(function () {\n            wx.getLocalImgData({\n              localId: t,\n              success: function success(e) {\n                n.src = e.localData;\n              }\n            });\n          });\n        }\n      }\n    }, !0), S.addEventListener("load", function (e) {\n      if (!M) {\n        var n = e.target,\n            i = n.tagName;\n        n.src;\n        if ("IMG" == i || "VIDEO" == i || "AUDIO" == i || "SOURCE" == i) {\n          var t = n["wx-id"];\n          t && (R[t] = !1);\n        }\n      }\n    }, !0), n && (e.wx = e.jWeixin = N), N;\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL193ZWl4aW4tanMtc2RrQDEuNC4wLXRlc3RAd2VpeGluLWpzLXNkay9pbmRleC5qcz85NWU1Il0sInNvdXJjZXNDb250ZW50IjpbIiEgZnVuY3Rpb24gKGUsIG4pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBuKGUpXG59KHdpbmRvdywgZnVuY3Rpb24gKGUsIG4pIHtcbiAgZnVuY3Rpb24gaShuLCBpLCB0KSB7XG4gICAgZS5XZWl4aW5KU0JyaWRnZSA/IFdlaXhpbkpTQnJpZGdlLmludm9rZShuLCBvKGkpLFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGMobiwgZSwgdClcbiAgICB9KSA6IHUobiwgdClcbiAgfVxuICBmdW5jdGlvbiB0KG4sIGksIHQpIHtcbiAgICBlLldlaXhpbkpTQnJpZGdlID8gV2VpeGluSlNCcmlkZ2Uub24obixcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICB0ICYmIHQudHJpZ2dlciAmJiB0LnRyaWdnZXIoZSksXG4gICAgICBjKG4sIGUsIGkpXG4gICAgfSkgOiB0ID8gdShuLCB0KSA6IHUobiwgaSlcbiAgfVxuICBmdW5jdGlvbiBvKGUpIHtcbiAgICByZXR1cm4gZSA9IGUgfHwge30sXG4gICAgZS5hcHBJZCA9IEMuYXBwSWQsXG4gICAgZS52ZXJpZnlBcHBJZCA9IEMuYXBwSWQsXG4gICAgZS52ZXJpZnlTaWduVHlwZSA9IFwic2hhMVwiLFxuICAgIGUudmVyaWZ5VGltZXN0YW1wID0gQy50aW1lc3RhbXAgKyBcIlwiLFxuICAgIGUudmVyaWZ5Tm9uY2VTdHIgPSBDLm5vbmNlU3RyLFxuICAgIGUudmVyaWZ5U2lnbmF0dXJlID0gQy5zaWduYXR1cmUsXG4gICAgZVxuICB9XG4gIGZ1bmN0aW9uIHIoZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lU3RhbXA6IGUudGltZXN0YW1wICsgXCJcIixcbiAgICAgIG5vbmNlU3RyOiBlLm5vbmNlU3RyLFxuICAgICAgcGFja2FnZTogZS5wYWNrYWdlLFxuICAgICAgcGF5U2lnbjogZS5wYXlTaWduLFxuICAgICAgc2lnblR5cGU6IGUuc2lnblR5cGUgfHwgXCJTSEExXCJcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYShlKSB7XG4gICAgcmV0dXJuIGUucG9zdGFsQ29kZSA9IGUuYWRkcmVzc1Bvc3RhbENvZGUsXG4gICAgZGVsZXRlIGUuYWRkcmVzc1Bvc3RhbENvZGUsXG4gICAgZS5wcm92aW5jZU5hbWUgPSBlLnByb3ZpY2VGaXJzdFN0YWdlTmFtZSxcbiAgICBkZWxldGUgZS5wcm92aWNlRmlyc3RTdGFnZU5hbWUsXG4gICAgZS5jaXR5TmFtZSA9IGUuYWRkcmVzc0NpdHlTZWNvbmRTdGFnZU5hbWUsXG4gICAgZGVsZXRlIGUuYWRkcmVzc0NpdHlTZWNvbmRTdGFnZU5hbWUsXG4gICAgZS5jb3VudHJ5TmFtZSA9IGUuYWRkcmVzc0NvdW50aWVzVGhpcmRTdGFnZU5hbWUsXG4gICAgZGVsZXRlIGUuYWRkcmVzc0NvdW50aWVzVGhpcmRTdGFnZU5hbWUsXG4gICAgZS5kZXRhaWxJbmZvID0gZS5hZGRyZXNzRGV0YWlsSW5mbyxcbiAgICBkZWxldGUgZS5hZGRyZXNzRGV0YWlsSW5mbyxcbiAgICBlXG4gIH1cbiAgZnVuY3Rpb24gYyhlLCBuLCBpKSB7XG4gICAgXCJvcGVuRW50ZXJwcmlzZUNoYXRcIiA9PSBlICYmIChuLmVyckNvZGUgPSBuLmVycl9jb2RlKSxcbiAgICBkZWxldGUgbi5lcnJfY29kZSxcbiAgICBkZWxldGUgbi5lcnJfZGVzYyxcbiAgICBkZWxldGUgbi5lcnJfZGV0YWlsO1xuICAgIHZhciB0ID0gbi5lcnJNc2c7XG4gICAgdCB8fCAodCA9IG4uZXJyX21zZywgZGVsZXRlIG4uZXJyX21zZywgdCA9IHMoZSwgdCksIG4uZXJyTXNnID0gdCksXG4gICAgKGkgPSBpIHx8IHt9KS5fY29tcGxldGUgJiYgKGkuX2NvbXBsZXRlKG4pLCBkZWxldGUgaS5fY29tcGxldGUpLFxuICAgIHQgPSBuLmVyck1zZyB8fCBcIlwiLFxuICAgIEMuZGVidWcgJiYgIWkuaXNJbm5lckludm9rZSAmJiBhbGVydChKU09OLnN0cmluZ2lmeShuKSk7XG4gICAgdmFyIG8gPSB0LmluZGV4T2YoXCI6XCIpO1xuICAgIHN3aXRjaCAodC5zdWJzdHJpbmcobyArIDEpKSB7XG4gICAgY2FzZSBcIm9rXCI6XG4gICAgICBpLnN1Y2Nlc3MgJiYgaS5zdWNjZXNzKG4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNhbmNlbFwiOlxuICAgICAgaS5jYW5jZWwgJiYgaS5jYW5jZWwobik7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaS5mYWlsICYmIGkuZmFpbChuKVxuICAgIH1cbiAgICBpLmNvbXBsZXRlICYmIGkuY29tcGxldGUobilcbiAgfVxuICBmdW5jdGlvbiBzKGUsIG4pIHtcbiAgICB2YXIgaSA9IGUsXG4gICAgdCA9IHZbaV07XG4gICAgdCAmJiAoaSA9IHQpO1xuICAgIHZhciBvID0gXCJva1wiO1xuICAgIGlmIChuKSB7XG4gICAgICB2YXIgciA9IG4uaW5kZXhPZihcIjpcIik7XG4gICAgICBcImNvbmZpcm1cIiA9PSAobyA9IG4uc3Vic3RyaW5nKHIgKyAxKSkgJiYgKG8gPSBcIm9rXCIpLFxuICAgICAgXCJmYWlsZWRcIiA9PSBvICYmIChvID0gXCJmYWlsXCIpLFxuICAgICAgLTEgIT0gby5pbmRleE9mKFwiZmFpbGVkX1wiKSAmJiAobyA9IG8uc3Vic3RyaW5nKDcpKSxcbiAgICAgIC0xICE9IG8uaW5kZXhPZihcImZhaWxfXCIpICYmIChvID0gby5zdWJzdHJpbmcoNSkpLFxuICAgICAgXCJhY2Nlc3MgZGVuaWVkXCIgIT0gKG8gPSAobyA9IG8ucmVwbGFjZSgvXy9nLCBcIiBcIikpLnRvTG93ZXJDYXNlKCkpICYmIFwibm8gcGVybWlzc2lvbiB0byBleGVjdXRlXCIgIT0gbyB8fCAobyA9IFwicGVybWlzc2lvbiBkZW5pZWRcIiksXG4gICAgICBcImNvbmZpZ1wiID09IGkgJiYgXCJmdW5jdGlvbiBub3QgZXhpc3RcIiA9PSBvICYmIChvID0gXCJva1wiKSxcbiAgICAgIFwiXCIgPT0gbyAmJiAobyA9IFwiZmFpbFwiKVxuICAgIH1cbiAgICByZXR1cm4gbiA9IGkgKyBcIjpcIiArIG9cbiAgfVxuICBmdW5jdGlvbiBkKGUpIHtcbiAgICBpZiAoZSkge1xuICAgICAgZm9yICh2YXIgbiA9IDAsXG4gICAgICBpID0gZS5sZW5ndGg7IG4gPCBpOyArK24pIHtcbiAgICAgICAgdmFyIHQgPSBlW25dLFxuICAgICAgICBvID0gaFt0XTtcbiAgICAgICAgbyAmJiAoZVtuXSA9IG8pXG4gICAgICB9XG4gICAgICByZXR1cm4gZVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1KGUsIG4pIHtcbiAgICBpZiAoISAoIUMuZGVidWcgfHwgbiAmJiBuLmlzSW5uZXJJbnZva2UpKSB7XG4gICAgICB2YXIgaSA9IHZbZV07XG4gICAgICBpICYmIChlID0gaSksXG4gICAgICBuICYmIG4uX2NvbXBsZXRlICYmIGRlbGV0ZSBuLl9jb21wbGV0ZSxcbiAgICAgIGNvbnNvbGUubG9nKCdcIicgKyBlICsgJ1wiLCcsIG4gfHwgXCJcIilcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbChlKSB7XG4gICAgaWYgKCEgKGsgfHwgdyB8fCBDLmRlYnVnIHx8IHggPCBcIjYuMC4yXCIgfHwgVi5zeXN0ZW1UeXBlIDwgMCkpIHtcbiAgICAgIHZhciBuID0gbmV3IEltYWdlO1xuICAgICAgVi5hcHBJZCA9IEMuYXBwSWQsXG4gICAgICBWLmluaXRUaW1lID0gQS5pbml0RW5kVGltZSAtIEEuaW5pdFN0YXJ0VGltZSxcbiAgICAgIFYucHJlVmVyaWZ5VGltZSA9IEEucHJlVmVyaWZ5RW5kVGltZSAtIEEucHJlVmVyaWZ5U3RhcnRUaW1lLFxuICAgICAgTi5nZXROZXR3b3JrVHlwZSh7XG4gICAgICAgIGlzSW5uZXJJbnZva2U6ICEwLFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgVi5uZXR3b3JrVHlwZSA9IGUubmV0d29ya1R5cGU7XG4gICAgICAgICAgdmFyIGkgPSBcImh0dHBzOi8vb3Blbi53ZWl4aW4ucXEuY29tL3Nkay9yZXBvcnQ/dj1cIiArIFYudmVyc2lvbiArIFwiJm89XCIgKyBWLmlzUHJlVmVyaWZ5T2sgKyBcIiZzPVwiICsgVi5zeXN0ZW1UeXBlICsgXCImYz1cIiArIFYuY2xpZW50VmVyc2lvbiArIFwiJmE9XCIgKyBWLmFwcElkICsgXCImbj1cIiArIFYubmV0d29ya1R5cGUgKyBcIiZpPVwiICsgVi5pbml0VGltZSArIFwiJnA9XCIgKyBWLnByZVZlcmlmeVRpbWUgKyBcIiZ1PVwiICsgVi51cmw7XG4gICAgICAgICAgbi5zcmMgPSBpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHAoKSB7XG4gICAgcmV0dXJuIChuZXcgRGF0ZSkuZ2V0VGltZSgpXG4gIH1cbiAgZnVuY3Rpb24gZihuKSB7XG4gICAgVCAmJiAoZS5XZWl4aW5KU0JyaWRnZSA/IG4oKSA6IFMuYWRkRXZlbnRMaXN0ZW5lciAmJiBTLmFkZEV2ZW50TGlzdGVuZXIoXCJXZWl4aW5KU0JyaWRnZVJlYWR5XCIsIG4sICExKSlcbiAgfVxuICBmdW5jdGlvbiBtKCkge1xuICAgIE4uaW52b2tlIHx8IChOLmludm9rZSA9IGZ1bmN0aW9uKG4sIGksIHQpIHtcbiAgICAgIGUuV2VpeGluSlNCcmlkZ2UgJiYgV2VpeGluSlNCcmlkZ2UuaW52b2tlKG4sIG8oaSksIHQpXG4gICAgfSxcbiAgICBOLm9uID0gZnVuY3Rpb24obiwgaSkge1xuICAgICAgZS5XZWl4aW5KU0JyaWRnZSAmJiBXZWl4aW5KU0JyaWRnZS5vbihuLCBpKVxuICAgIH0pXG4gIH1cbiAgZnVuY3Rpb24gZyhlKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgZS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbiA9IGUuc3BsaXQoXCI/XCIpWzBdLFxuICAgICAgaSA9IGUuc3BsaXQoXCI/XCIpWzFdO1xuICAgICAgcmV0dXJuIG4gKz0gXCIuaHRtbFwiLFxuICAgICAgdm9pZCAwICE9PSBpID8gbiArIFwiP1wiICsgaTogblxuICAgIH1cbiAgfVxuICBpZiAoIWUualdlaXhpbikge1xuICAgIHZhciBoID0ge1xuICAgICAgY29uZmlnOiBcInByZVZlcmlmeUpTQVBJXCIsXG4gICAgICBvbk1lbnVTaGFyZVRpbWVsaW5lOiBcIm1lbnU6c2hhcmU6dGltZWxpbmVcIixcbiAgICAgIG9uTWVudVNoYXJlQXBwTWVzc2FnZTogXCJtZW51OnNoYXJlOmFwcG1lc3NhZ2VcIixcbiAgICAgIG9uTWVudVNoYXJlUVE6IFwibWVudTpzaGFyZTpxcVwiLFxuICAgICAgb25NZW51U2hhcmVXZWlibzogXCJtZW51OnNoYXJlOndlaWJvQXBwXCIsXG4gICAgICBvbk1lbnVTaGFyZVFab25lOiBcIm1lbnU6c2hhcmU6UVpvbmVcIixcbiAgICAgIHByZXZpZXdJbWFnZTogXCJpbWFnZVByZXZpZXdcIixcbiAgICAgIGdldExvY2F0aW9uOiBcImdlb0xvY2F0aW9uXCIsXG4gICAgICBvcGVuUHJvZHVjdFNwZWNpZmljVmlldzogXCJvcGVuUHJvZHVjdFZpZXdXaXRoUGlkXCIsXG4gICAgICBhZGRDYXJkOiBcImJhdGNoQWRkQ2FyZFwiLFxuICAgICAgb3BlbkNhcmQ6IFwiYmF0Y2hWaWV3Q2FyZFwiLFxuICAgICAgY2hvb3NlV1hQYXk6IFwiZ2V0QnJhbmRXQ1BheVJlcXVlc3RcIixcbiAgICAgIG9wZW5FbnRlcnByaXNlUmVkUGFja2V0OiBcImdldFJlY2V2aWVCaXpIb25nQmFvUmVxdWVzdFwiLFxuICAgICAgc3RhcnRTZWFyY2hCZWFjb25zOiBcInN0YXJ0TW9uaXRvcmluZ0JlYWNvbnNcIixcbiAgICAgIHN0b3BTZWFyY2hCZWFjb25zOiBcInN0b3BNb25pdG9yaW5nQmVhY29uc1wiLFxuICAgICAgb25TZWFyY2hCZWFjb25zOiBcIm9uQmVhY29uc0luUmFuZ2VcIixcbiAgICAgIGNvbnN1bWVBbmRTaGFyZUNhcmQ6IFwiY29uc3VtZWRTaGFyZUNhcmRcIixcbiAgICAgIG9wZW5BZGRyZXNzOiBcImVkaXRBZGRyZXNzXCJcbiAgICB9LFxuICAgIHYgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0ge307XG4gICAgICBmb3IgKHZhciBuIGluIGgpIGVbaFtuXV0gPSBuO1xuICAgICAgcmV0dXJuIGVcbiAgICB9ICgpLFxuICAgIFMgPSBlLmRvY3VtZW50LFxuICAgIEkgPSBTLnRpdGxlLFxuICAgIHkgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG4gICAgXyA9IG5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpLFxuICAgIGsgPSAhKCFfLm1hdGNoKFwibWFjXCIpICYmICFfLm1hdGNoKFwid2luXCIpKSxcbiAgICB3ID0gLTEgIT0geS5pbmRleE9mKFwid3hkZWJ1Z2dlclwiKSxcbiAgICBUID0gLTEgIT0geS5pbmRleE9mKFwibWljcm9tZXNzZW5nZXJcIiksXG4gICAgTSA9IC0xICE9IHkuaW5kZXhPZihcImFuZHJvaWRcIiksXG4gICAgUCA9IC0xICE9IHkuaW5kZXhPZihcImlwaG9uZVwiKSB8fCAtMSAhPSB5LmluZGV4T2YoXCJpcGFkXCIpLFxuICAgIHggPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0geS5tYXRjaCgvbWljcm9tZXNzZW5nZXJcXC8oXFxkK1xcLlxcZCtcXC5cXGQrKS8pIHx8IHkubWF0Y2goL21pY3JvbWVzc2VuZ2VyXFwvKFxcZCtcXC5cXGQrKS8pO1xuICAgICAgcmV0dXJuIGUgPyBlWzFdIDogXCJcIlxuICAgIH0gKCksXG4gICAgQSA9IHtcbiAgICAgIGluaXRTdGFydFRpbWU6IHAoKSxcbiAgICAgIGluaXRFbmRUaW1lOiAwLFxuICAgICAgcHJlVmVyaWZ5U3RhcnRUaW1lOiAwLFxuICAgICAgcHJlVmVyaWZ5RW5kVGltZTogMFxuICAgIH0sXG4gICAgViA9IHtcbiAgICAgIHZlcnNpb246IDEsXG4gICAgICBhcHBJZDogXCJcIixcbiAgICAgIGluaXRUaW1lOiAwLFxuICAgICAgcHJlVmVyaWZ5VGltZTogMCxcbiAgICAgIG5ldHdvcmtUeXBlOiBcIlwiLFxuICAgICAgaXNQcmVWZXJpZnlPazogMSxcbiAgICAgIHN5c3RlbVR5cGU6IFAgPyAxIDogTSA/IDIgOiAtMSxcbiAgICAgIGNsaWVudFZlcnNpb246IHgsXG4gICAgICB1cmw6IGVuY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5ocmVmKVxuICAgIH0sXG4gICAgQyA9IHt9LFxuICAgIEwgPSB7XG4gICAgICBfY29tcGxldGVzOiBbXVxuICAgIH0sXG4gICAgQiA9IHtcbiAgICAgIHN0YXRlOiAwLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGYoZnVuY3Rpb24oKSB7XG4gICAgICBBLmluaXRFbmRUaW1lID0gcCgpXG4gICAgfSk7XG4gICAgdmFyIE8gPSAhMSxcbiAgICBFID0gW10sXG4gICAgTiA9IHtcbiAgICAgIGNvbmZpZzogZnVuY3Rpb24oZSkge1xuICAgICAgICBDID0gZSxcbiAgICAgICAgdShcImNvbmZpZ1wiLCBlKTtcbiAgICAgICAgdmFyIG4gPSAhMSAhPT0gQy5jaGVjaztcbiAgICAgICAgZihmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAobikgaShoLmNvbmZpZywge1xuICAgICAgICAgICAgdmVyaWZ5SnNBcGlMaXN0OiBkKEMuanNBcGlMaXN0KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBMLl9jb21wbGV0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgQS5wcmVWZXJpZnlFbmRUaW1lID0gcCgpLFxuICAgICAgICAgICAgICBCLnN0YXRlID0gMSxcbiAgICAgICAgICAgICAgQi5kYXRhID0gZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEwuc3VjY2VzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgVi5pc1ByZVZlcmlmeU9rID0gMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEwuZmFpbCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgTC5fZmFpbCA/IEwuX2ZhaWwoZSkgOiBCLnN0YXRlID0gLTFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZSA9IEwuX2NvbXBsZXRlcztcbiAgICAgICAgICAgIHJldHVybiBlLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBMLmNvbXBsZXRlID0gZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCxcbiAgICAgICAgICAgICAgdCA9IGUubGVuZ3RoOyBpIDwgdDsgKytpKSBlW2ldKCk7XG4gICAgICAgICAgICAgIEwuX2NvbXBsZXRlcyA9IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTFxuICAgICAgICAgIH0gKCkpLFxuICAgICAgICAgIEEucHJlVmVyaWZ5U3RhcnRUaW1lID0gcCgpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgQi5zdGF0ZSA9IDE7XG4gICAgICAgICAgICBmb3IgKHZhciBlID0gTC5fY29tcGxldGVzLFxuICAgICAgICAgICAgdCA9IDAsXG4gICAgICAgICAgICBvID0gZS5sZW5ndGg7IHQgPCBvOyArK3QpIGVbdF0oKTtcbiAgICAgICAgICAgIEwuX2NvbXBsZXRlcyA9IFtdXG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgbSgpXG4gICAgICB9LFxuICAgICAgcmVhZHk6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgMCAhPSBCLnN0YXRlID8gZSgpIDogKEwuX2NvbXBsZXRlcy5wdXNoKGUpLCAhVCAmJiBDLmRlYnVnICYmIGUoKSlcbiAgICAgIH0sXG4gICAgICBlcnJvcjogZnVuY3Rpb24oZSkge1xuICAgICAgICB4IDwgXCI2LjAuMlwiIHx8ICggLSAxID09IEIuc3RhdGUgPyBlKEIuZGF0YSkgOiBMLl9mYWlsID0gZSlcbiAgICAgIH0sXG4gICAgICBjaGVja0pzQXBpOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBuID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHZhciBuID0gZS5jaGVja1Jlc3VsdDtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIG4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gdltpXTtcbiAgICAgICAgICAgIHQgJiYgKG5bdF0gPSBuW2ldLCBkZWxldGUgbltpXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgfTtcbiAgICAgICAgaShcImNoZWNrSnNBcGlcIiwge1xuICAgICAgICAgIGpzQXBpTGlzdDogZChlLmpzQXBpTGlzdClcbiAgICAgICAgfSxcbiAgICAgICAgKGUuX2NvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmIChNKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGUuY2hlY2tSZXN1bHQ7XG4gICAgICAgICAgICBpICYmIChlLmNoZWNrUmVzdWx0ID0gSlNPTi5wYXJzZShpKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZSA9IG4oZSlcbiAgICAgICAgfSxcbiAgICAgICAgZSkpXG4gICAgICB9LFxuICAgICAgb25NZW51U2hhcmVUaW1lbGluZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0KGgub25NZW51U2hhcmVUaW1lbGluZSwge1xuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGkoXCJzaGFyZVRpbWVsaW5lXCIsIHtcbiAgICAgICAgICAgICAgdGl0bGU6IGUudGl0bGUgfHwgSSxcbiAgICAgICAgICAgICAgZGVzYzogZS50aXRsZSB8fCBJLFxuICAgICAgICAgICAgICBpbWdfdXJsOiBlLmltZ1VybCB8fCBcIlwiLFxuICAgICAgICAgICAgICBsaW5rOiBlLmxpbmsgfHwgbG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgICAgdHlwZTogZS50eXBlIHx8IFwibGlua1wiLFxuICAgICAgICAgICAgICBkYXRhX3VybDogZS5kYXRhVXJsIHx8IFwiXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBvbk1lbnVTaGFyZUFwcE1lc3NhZ2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdChoLm9uTWVudVNoYXJlQXBwTWVzc2FnZSwge1xuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICBcImZhdm9yaXRlXCIgPT09IG4uc2NlbmUgPyBpKFwic2VuZEFwcE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgICB0aXRsZTogZS50aXRsZSB8fCBJLFxuICAgICAgICAgICAgICBkZXNjOiBlLmRlc2MgfHwgXCJcIixcbiAgICAgICAgICAgICAgbGluazogZS5saW5rIHx8IGxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICAgIGltZ191cmw6IGUuaW1nVXJsIHx8IFwiXCIsXG4gICAgICAgICAgICAgIHR5cGU6IGUudHlwZSB8fCBcImxpbmtcIixcbiAgICAgICAgICAgICAgZGF0YV91cmw6IGUuZGF0YVVybCB8fCBcIlwiXG4gICAgICAgICAgICB9KSA6IGkoXCJzZW5kQXBwTWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAgIHRpdGxlOiBlLnRpdGxlIHx8IEksXG4gICAgICAgICAgICAgIGRlc2M6IGUuZGVzYyB8fCBcIlwiLFxuICAgICAgICAgICAgICBsaW5rOiBlLmxpbmsgfHwgbG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgICAgaW1nX3VybDogZS5pbWdVcmwgfHwgXCJcIixcbiAgICAgICAgICAgICAgdHlwZTogZS50eXBlIHx8IFwibGlua1wiLFxuICAgICAgICAgICAgICBkYXRhX3VybDogZS5kYXRhVXJsIHx8IFwiXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBvbk1lbnVTaGFyZVFROiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHQoaC5vbk1lbnVTaGFyZVFRLCB7XG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaShcInNoYXJlUVFcIiwge1xuICAgICAgICAgICAgICB0aXRsZTogZS50aXRsZSB8fCBJLFxuICAgICAgICAgICAgICBkZXNjOiBlLmRlc2MgfHwgXCJcIixcbiAgICAgICAgICAgICAgaW1nX3VybDogZS5pbWdVcmwgfHwgXCJcIixcbiAgICAgICAgICAgICAgbGluazogZS5saW5rIHx8IGxvY2F0aW9uLmhyZWZcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBvbk1lbnVTaGFyZVdlaWJvOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHQoaC5vbk1lbnVTaGFyZVdlaWJvLCB7XG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaShcInNoYXJlV2VpYm9BcHBcIiwge1xuICAgICAgICAgICAgICB0aXRsZTogZS50aXRsZSB8fCBJLFxuICAgICAgICAgICAgICBkZXNjOiBlLmRlc2MgfHwgXCJcIixcbiAgICAgICAgICAgICAgaW1nX3VybDogZS5pbWdVcmwgfHwgXCJcIixcbiAgICAgICAgICAgICAgbGluazogZS5saW5rIHx8IGxvY2F0aW9uLmhyZWZcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBvbk1lbnVTaGFyZVFab25lOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHQoaC5vbk1lbnVTaGFyZVFab25lLCB7XG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaShcInNoYXJlUVpvbmVcIiwge1xuICAgICAgICAgICAgICB0aXRsZTogZS50aXRsZSB8fCBJLFxuICAgICAgICAgICAgICBkZXNjOiBlLmRlc2MgfHwgXCJcIixcbiAgICAgICAgICAgICAgaW1nX3VybDogZS5pbWdVcmwgfHwgXCJcIixcbiAgICAgICAgICAgICAgbGluazogZS5saW5rIHx8IGxvY2F0aW9uLmhyZWZcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICB1cGRhdGVUaW1lbGluZVNoYXJlRGF0YTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpKFwidXBkYXRlVGltZWxpbmVTaGFyZURhdGFcIiwge1xuICAgICAgICAgIHRpdGxlOiBlLnRpdGxlLFxuICAgICAgICAgIGxpbms6IGUubGluayxcbiAgICAgICAgICBpbWdVcmw6IGUuaW1nVXJsXG4gICAgICAgIH0sXG4gICAgICAgIGUpXG4gICAgICB9LFxuICAgICAgdXBkYXRlQXBwTWVzc2FnZVNoYXJlRGF0YTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpKFwidXBkYXRlQXBwTWVzc2FnZVNoYXJlRGF0YVwiLCB7XG4gICAgICAgICAgdGl0bGU6IGUudGl0bGUsXG4gICAgICAgICAgZGVzYzogZS5kZXNjLFxuICAgICAgICAgIGxpbms6IGUubGluayxcbiAgICAgICAgICBpbWdVcmw6IGUuaW1nVXJsXG4gICAgICAgIH0sXG4gICAgICAgIGUpXG4gICAgICB9LFxuICAgICAgc3RhcnRSZWNvcmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaShcInN0YXJ0UmVjb3JkXCIsIHt9LFxuICAgICAgICBlKVxuICAgICAgfSxcbiAgICAgIHN0b3BSZWNvcmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaShcInN0b3BSZWNvcmRcIiwge30sXG4gICAgICAgIGUpXG4gICAgICB9LFxuICAgICAgb25Wb2ljZVJlY29yZEVuZDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0KFwib25Wb2ljZVJlY29yZEVuZFwiLCBlKVxuICAgICAgfSxcbiAgICAgIHBsYXlWb2ljZTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpKFwicGxheVZvaWNlXCIsIHtcbiAgICAgICAgICBsb2NhbElkOiBlLmxvY2FsSWRcbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBwYXVzZVZvaWNlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGkoXCJwYXVzZVZvaWNlXCIsIHtcbiAgICAgICAgICBsb2NhbElkOiBlLmxvY2FsSWRcbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBzdG9wVm9pY2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaShcInN0b3BWb2ljZVwiLCB7XG4gICAgICAgICAgbG9jYWxJZDogZS5sb2NhbElkXG4gICAgICAgIH0sXG4gICAgICAgIGUpXG4gICAgICB9LFxuICAgICAgb25Wb2ljZVBsYXlFbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdChcIm9uVm9pY2VQbGF5RW5kXCIsIGUpXG4gICAgICB9LFxuICAgICAgdXBsb2FkVm9pY2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaShcInVwbG9hZFZvaWNlXCIsIHtcbiAgICAgICAgICBsb2NhbElkOiBlLmxvY2FsSWQsXG4gICAgICAgICAgaXNTaG93UHJvZ3Jlc3NUaXBzOiAwID09IGUuaXNTaG93UHJvZ3Jlc3NUaXBzID8gMCA6IDFcbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBkb3dubG9hZFZvaWNlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGkoXCJkb3dubG9hZFZvaWNlXCIsIHtcbiAgICAgICAgICBzZXJ2ZXJJZDogZS5zZXJ2ZXJJZCxcbiAgICAgICAgICBpc1Nob3dQcm9ncmVzc1RpcHM6IDAgPT0gZS5pc1Nob3dQcm9ncmVzc1RpcHMgPyAwIDogMVxuICAgICAgICB9LFxuICAgICAgICBlKVxuICAgICAgfSxcbiAgICAgIHRyYW5zbGF0ZVZvaWNlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGkoXCJ0cmFuc2xhdGVWb2ljZVwiLCB7XG4gICAgICAgICAgbG9jYWxJZDogZS5sb2NhbElkLFxuICAgICAgICAgIGlzU2hvd1Byb2dyZXNzVGlwczogMCA9PSBlLmlzU2hvd1Byb2dyZXNzVGlwcyA/IDAgOiAxXG4gICAgICAgIH0sXG4gICAgICAgIGUpXG4gICAgICB9LFxuICAgICAgY2hvb3NlSW1hZ2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaShcImNob29zZUltYWdlXCIsIHtcbiAgICAgICAgICBzY2VuZTogXCIxfDJcIixcbiAgICAgICAgICBjb3VudDogZS5jb3VudCB8fCA5LFxuICAgICAgICAgIHNpemVUeXBlOiBlLnNpemVUeXBlIHx8IFtcIm9yaWdpbmFsXCIsIFwiY29tcHJlc3NlZFwiXSxcbiAgICAgICAgICBzb3VyY2VUeXBlOiBlLnNvdXJjZVR5cGUgfHwgW1wiYWxidW1cIiwgXCJjYW1lcmFcIl1cbiAgICAgICAgfSxcbiAgICAgICAgKGUuX2NvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmIChNKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGUubG9jYWxJZHM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBuICYmIChlLmxvY2FsSWRzID0gSlNPTi5wYXJzZShuKSlcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGUpKVxuICAgICAgfSxcbiAgICAgIGdldExvY2F0aW9uOiBmdW5jdGlvbihlKSB7fSxcbiAgICAgIHByZXZpZXdJbWFnZTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpKGgucHJldmlld0ltYWdlLCB7XG4gICAgICAgICAgY3VycmVudDogZS5jdXJyZW50LFxuICAgICAgICAgIHVybHM6IGUudXJsc1xuICAgICAgICB9LFxuICAgICAgICBlKVxuICAgICAgfSxcbiAgICAgIHVwbG9hZEltYWdlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGkoXCJ1cGxvYWRJbWFnZVwiLCB7XG4gICAgICAgICAgbG9jYWxJZDogZS5sb2NhbElkLFxuICAgICAgICAgIGlzU2hvd1Byb2dyZXNzVGlwczogMCA9PSBlLmlzU2hvd1Byb2dyZXNzVGlwcyA/IDAgOiAxXG4gICAgICAgIH0sXG4gICAgICAgIGUpXG4gICAgICB9LFxuICAgICAgZG93bmxvYWRJbWFnZTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpKFwiZG93bmxvYWRJbWFnZVwiLCB7XG4gICAgICAgICAgc2VydmVySWQ6IGUuc2VydmVySWQsXG4gICAgICAgICAgaXNTaG93UHJvZ3Jlc3NUaXBzOiAwID09IGUuaXNTaG93UHJvZ3Jlc3NUaXBzID8gMCA6IDFcbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBnZXRMb2NhbEltZ0RhdGE6IGZ1bmN0aW9uKGUpIHsgISAxID09PSBPID8gKE8gPSAhMCwgaShcImdldExvY2FsSW1nRGF0YVwiLCB7XG4gICAgICAgICAgbG9jYWxJZDogZS5sb2NhbElkXG4gICAgICAgIH0sXG4gICAgICAgIChlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoTyA9ICExLCBFLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBuID0gRS5zaGlmdCgpO1xuICAgICAgICAgICAgd3guZ2V0TG9jYWxJbWdEYXRhKG4pXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlKSkpIDogRS5wdXNoKGUpXG4gICAgICB9LFxuICAgICAgZ2V0TmV0d29ya1R5cGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIG4gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdmFyIG4gPSBlLmVyck1zZztcbiAgICAgICAgICBlLmVyck1zZyA9IFwiZ2V0TmV0d29ya1R5cGU6b2tcIjtcbiAgICAgICAgICB2YXIgaSA9IGUuc3VidHlwZTtcbiAgICAgICAgICBpZiAoZGVsZXRlIGUuc3VidHlwZSwgaSkgZS5uZXR3b3JrVHlwZSA9IGk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdCA9IG4uaW5kZXhPZihcIjpcIiksXG4gICAgICAgICAgICBvID0gbi5zdWJzdHJpbmcodCArIDEpO1xuICAgICAgICAgICAgc3dpdGNoIChvKSB7XG4gICAgICAgICAgICBjYXNlIFwid2lmaVwiOlxuICAgICAgICAgICAgY2FzZSBcImVkZ2VcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ3d2FuXCI6XG4gICAgICAgICAgICAgIGUubmV0d29ya1R5cGUgPSBvO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGUuZXJyTXNnID0gXCJnZXROZXR3b3JrVHlwZTpmYWlsXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgfTtcbiAgICAgICAgaShcImdldE5ldHdvcmtUeXBlXCIsIHt9LFxuICAgICAgICAoZS5fY29tcGxldGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZSA9IG4oZSlcbiAgICAgICAgfSxcbiAgICAgICAgZSkpXG4gICAgICB9LFxuICAgICAgb3BlbkxvY2F0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGkoXCJvcGVuTG9jYXRpb25cIiwge1xuICAgICAgICAgIGxhdGl0dWRlOiBlLmxhdGl0dWRlLFxuICAgICAgICAgIGxvbmdpdHVkZTogZS5sb25naXR1ZGUsXG4gICAgICAgICAgbmFtZTogZS5uYW1lIHx8IFwiXCIsXG4gICAgICAgICAgYWRkcmVzczogZS5hZGRyZXNzIHx8IFwiXCIsXG4gICAgICAgICAgc2NhbGU6IGUuc2NhbGUgfHwgMjgsXG4gICAgICAgICAgaW5mb1VybDogZS5pbmZvVXJsIHx8IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBnZXRMb2NhdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICBlID0gZSB8fCB7fSxcbiAgICAgICAgaShoLmdldExvY2F0aW9uLCB7XG4gICAgICAgICAgdHlwZTogZS50eXBlIHx8IFwid2dzODRcIlxuICAgICAgICB9LFxuICAgICAgICAoZS5fY29tcGxldGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZGVsZXRlIGUudHlwZVxuICAgICAgICB9LFxuICAgICAgICBlKSlcbiAgICAgIH0sXG4gICAgICBoaWRlT3B0aW9uTWVudTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpKFwiaGlkZU9wdGlvbk1lbnVcIiwge30sXG4gICAgICAgIGUpXG4gICAgICB9LFxuICAgICAgc2hvd09wdGlvbk1lbnU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaShcInNob3dPcHRpb25NZW51XCIsIHt9LFxuICAgICAgICBlKVxuICAgICAgfSxcbiAgICAgIGNsb3NlV2luZG93OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGkoXCJjbG9zZVdpbmRvd1wiLCB7fSxcbiAgICAgICAgZSA9IGUgfHwge30pXG4gICAgICB9LFxuICAgICAgaGlkZU1lbnVJdGVtczogZnVuY3Rpb24oZSkge1xuICAgICAgICBpKFwiaGlkZU1lbnVJdGVtc1wiLCB7XG4gICAgICAgICAgbWVudUxpc3Q6IGUubWVudUxpc3RcbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBzaG93TWVudUl0ZW1zOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGkoXCJzaG93TWVudUl0ZW1zXCIsIHtcbiAgICAgICAgICBtZW51TGlzdDogZS5tZW51TGlzdFxuICAgICAgICB9LFxuICAgICAgICBlKVxuICAgICAgfSxcbiAgICAgIGhpZGVBbGxOb25CYXNlTWVudUl0ZW06IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaShcImhpZGVBbGxOb25CYXNlTWVudUl0ZW1cIiwge30sXG4gICAgICAgIGUpXG4gICAgICB9LFxuICAgICAgc2hvd0FsbE5vbkJhc2VNZW51SXRlbTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpKFwic2hvd0FsbE5vbkJhc2VNZW51SXRlbVwiLCB7fSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBzY2FuUVJDb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGkoXCJzY2FuUVJDb2RlXCIsIHtcbiAgICAgICAgICBuZWVkUmVzdWx0OiAoZSA9IGUgfHwge30pLm5lZWRSZXN1bHQgfHwgMCxcbiAgICAgICAgICBzY2FuVHlwZTogZS5zY2FuVHlwZSB8fCBbXCJxckNvZGVcIiwgXCJiYXJDb2RlXCJdXG4gICAgICAgIH0sXG4gICAgICAgIChlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoUCkge1xuICAgICAgICAgICAgdmFyIG4gPSBlLnJlc3VsdFN0cjtcbiAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gSlNPTi5wYXJzZShuKTtcbiAgICAgICAgICAgICAgZS5yZXN1bHRTdHIgPSBpICYmIGkuc2Nhbl9jb2RlICYmIGkuc2Nhbl9jb2RlLnNjYW5fcmVzdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlKSlcbiAgICAgIH0sXG4gICAgICBvcGVuQWRkcmVzczogZnVuY3Rpb24oZSkge1xuICAgICAgICBpKGgub3BlbkFkZHJlc3MsIHt9LFxuICAgICAgICAoZS5fY29tcGxldGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZSA9IGEoZSlcbiAgICAgICAgfSxcbiAgICAgICAgZSkpXG4gICAgICB9LFxuICAgICAgb3BlblByb2R1Y3RTcGVjaWZpY1ZpZXc6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaShoLm9wZW5Qcm9kdWN0U3BlY2lmaWNWaWV3LCB7XG4gICAgICAgICAgcGlkOiBlLnByb2R1Y3RJZCxcbiAgICAgICAgICB2aWV3X3R5cGU6IGUudmlld1R5cGUgfHwgMCxcbiAgICAgICAgICBleHRfaW5mbzogZS5leHRJbmZvXG4gICAgICAgIH0sXG4gICAgICAgIGUpXG4gICAgICB9LFxuICAgICAgYWRkQ2FyZDogZnVuY3Rpb24oZSkge1xuICAgICAgICBmb3IgKHZhciBuID0gZS5jYXJkTGlzdCxcbiAgICAgICAgdCA9IFtdLCBvID0gMCwgciA9IG4ubGVuZ3RoOyBvIDwgcjsgKytvKSB7XG4gICAgICAgICAgdmFyIGEgPSBuW29dLFxuICAgICAgICAgIGMgPSB7XG4gICAgICAgICAgICBjYXJkX2lkOiBhLmNhcmRJZCxcbiAgICAgICAgICAgIGNhcmRfZXh0OiBhLmNhcmRFeHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHQucHVzaChjKVxuICAgICAgICB9XG4gICAgICAgIGkoaC5hZGRDYXJkLCB7XG4gICAgICAgICAgY2FyZF9saXN0OiB0XG4gICAgICAgIH0sXG4gICAgICAgIChlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgbiA9IGUuY2FyZF9saXN0O1xuICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCxcbiAgICAgICAgICAgIHQgPSAobiA9IEpTT04ucGFyc2UobikpLmxlbmd0aDsgaSA8IHQ7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgbyA9IG5baV07XG4gICAgICAgICAgICAgIG8uY2FyZElkID0gby5jYXJkX2lkLFxuICAgICAgICAgICAgICBvLmNhcmRFeHQgPSBvLmNhcmRfZXh0LFxuICAgICAgICAgICAgICBvLmlzU3VjY2VzcyA9ICEhby5pc19zdWNjLFxuICAgICAgICAgICAgICBkZWxldGUgby5jYXJkX2lkLFxuICAgICAgICAgICAgICBkZWxldGUgby5jYXJkX2V4dCxcbiAgICAgICAgICAgICAgZGVsZXRlIG8uaXNfc3VjY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5jYXJkTGlzdCA9IG4sXG4gICAgICAgICAgICBkZWxldGUgZS5jYXJkX2xpc3RcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGUpKVxuICAgICAgfSxcbiAgICAgIGNob29zZUNhcmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaShcImNob29zZUNhcmRcIiwge1xuICAgICAgICAgIGFwcF9pZDogQy5hcHBJZCxcbiAgICAgICAgICBsb2NhdGlvbl9pZDogZS5zaG9wSWQgfHwgXCJcIixcbiAgICAgICAgICBzaWduX3R5cGU6IGUuc2lnblR5cGUgfHwgXCJTSEExXCIsXG4gICAgICAgICAgY2FyZF9pZDogZS5jYXJkSWQgfHwgXCJcIixcbiAgICAgICAgICBjYXJkX3R5cGU6IGUuY2FyZFR5cGUgfHwgXCJcIixcbiAgICAgICAgICBjYXJkX3NpZ246IGUuY2FyZFNpZ24sXG4gICAgICAgICAgdGltZV9zdGFtcDogZS50aW1lc3RhbXAgKyBcIlwiLFxuICAgICAgICAgIG5vbmNlX3N0cjogZS5ub25jZVN0clxuICAgICAgICB9LFxuICAgICAgICAoZS5fY29tcGxldGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZS5jYXJkTGlzdCA9IGUuY2hvb3NlX2NhcmRfaW5mbyxcbiAgICAgICAgICBkZWxldGUgZS5jaG9vc2VfY2FyZF9pbmZvXG4gICAgICAgIH0sXG4gICAgICAgIGUpKVxuICAgICAgfSxcbiAgICAgIG9wZW5DYXJkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGZvciAodmFyIG4gPSBlLmNhcmRMaXN0LFxuICAgICAgICB0ID0gW10sIG8gPSAwLCByID0gbi5sZW5ndGg7IG8gPCByOyArK28pIHtcbiAgICAgICAgICB2YXIgYSA9IG5bb10sXG4gICAgICAgICAgYyA9IHtcbiAgICAgICAgICAgIGNhcmRfaWQ6IGEuY2FyZElkLFxuICAgICAgICAgICAgY29kZTogYS5jb2RlXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0LnB1c2goYylcbiAgICAgICAgfVxuICAgICAgICBpKGgub3BlbkNhcmQsIHtcbiAgICAgICAgICBjYXJkX2xpc3Q6IHRcbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBjb25zdW1lQW5kU2hhcmVDYXJkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGkoaC5jb25zdW1lQW5kU2hhcmVDYXJkLCB7XG4gICAgICAgICAgY29uc3VtZWRDYXJkSWQ6IGUuY2FyZElkLFxuICAgICAgICAgIGNvbnN1bWVkQ29kZTogZS5jb2RlXG4gICAgICAgIH0sXG4gICAgICAgIGUpXG4gICAgICB9LFxuICAgICAgY2hvb3NlV1hQYXk6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaShoLmNob29zZVdYUGF5LCByKGUpLCBlKVxuICAgICAgfSxcbiAgICAgIG9wZW5FbnRlcnByaXNlUmVkUGFja2V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGkoaC5vcGVuRW50ZXJwcmlzZVJlZFBhY2tldCwgcihlKSwgZSlcbiAgICAgIH0sXG4gICAgICBzdGFydFNlYXJjaEJlYWNvbnM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaShoLnN0YXJ0U2VhcmNoQmVhY29ucywge1xuICAgICAgICAgIHRpY2tldDogZS50aWNrZXRcbiAgICAgICAgfSxcbiAgICAgICAgZSlcbiAgICAgIH0sXG4gICAgICBzdG9wU2VhcmNoQmVhY29uczogZnVuY3Rpb24oZSkge1xuICAgICAgICBpKGguc3RvcFNlYXJjaEJlYWNvbnMsIHt9LFxuICAgICAgICBlKVxuICAgICAgfSxcbiAgICAgIG9uU2VhcmNoQmVhY29uczogZnVuY3Rpb24oZSkge1xuICAgICAgICB0KGgub25TZWFyY2hCZWFjb25zLCBlKVxuICAgICAgfSxcbiAgICAgIG9wZW5FbnRlcnByaXNlQ2hhdDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpKFwib3BlbkVudGVycHJpc2VDaGF0XCIsIHtcbiAgICAgICAgICB1c2VyaWRsaXN0OiBlLnVzZXJJZHMsXG4gICAgICAgICAgY2hhdG5hbWU6IGUuZ3JvdXBOYW1lXG4gICAgICAgIH0sXG4gICAgICAgIGUpXG4gICAgICB9LFxuICAgICAgbGF1bmNoTWluaVByb2dyYW06IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaShcImxhdW5jaE1pbmlQcm9ncmFtXCIsIHtcbiAgICAgICAgICB0YXJnZXRBcHBJZDogZS50YXJnZXRBcHBJZCxcbiAgICAgICAgICBwYXRoOiBnKGUucGF0aCksXG4gICAgICAgICAgZW52VmVyc2lvbjogZS5lbnZWZXJzaW9uXG4gICAgICAgIH0sXG4gICAgICAgIGUpXG4gICAgICB9LFxuICAgICAgbWluaVByb2dyYW06IHtcbiAgICAgICAgbmF2aWdhdGVCYWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZSA9IGUgfHwge30sXG4gICAgICAgICAgZihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGkoXCJpbnZva2VNaW5pUHJvZ3JhbUFQSVwiLCB7XG4gICAgICAgICAgICAgIG5hbWU6IFwibmF2aWdhdGVCYWNrXCIsXG4gICAgICAgICAgICAgIGFyZzoge1xuICAgICAgICAgICAgICAgIGRlbHRhOiBlLmRlbHRhIHx8IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgbmF2aWdhdGVUbzogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGYoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpKFwiaW52b2tlTWluaVByb2dyYW1BUElcIiwge1xuICAgICAgICAgICAgICBuYW1lOiBcIm5hdmlnYXRlVG9cIixcbiAgICAgICAgICAgICAgYXJnOiB7XG4gICAgICAgICAgICAgICAgdXJsOiBlLnVybFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICByZWRpcmVjdFRvOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGkoXCJpbnZva2VNaW5pUHJvZ3JhbUFQSVwiLCB7XG4gICAgICAgICAgICAgIG5hbWU6IFwicmVkaXJlY3RUb1wiLFxuICAgICAgICAgICAgICBhcmc6IHtcbiAgICAgICAgICAgICAgICB1cmw6IGUudXJsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHN3aXRjaFRhYjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGYoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpKFwiaW52b2tlTWluaVByb2dyYW1BUElcIiwge1xuICAgICAgICAgICAgICBuYW1lOiBcInN3aXRjaFRhYlwiLFxuICAgICAgICAgICAgICBhcmc6IHtcbiAgICAgICAgICAgICAgICB1cmw6IGUudXJsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHJlTGF1bmNoOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGkoXCJpbnZva2VNaW5pUHJvZ3JhbUFQSVwiLCB7XG4gICAgICAgICAgICAgIG5hbWU6IFwicmVMYXVuY2hcIixcbiAgICAgICAgICAgICAgYXJnOiB7XG4gICAgICAgICAgICAgICAgdXJsOiBlLnVybFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBwb3N0TWVzc2FnZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGYoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpKFwiaW52b2tlTWluaVByb2dyYW1BUElcIiwge1xuICAgICAgICAgICAgICBuYW1lOiBcInBvc3RNZXNzYWdlXCIsXG4gICAgICAgICAgICAgIGFyZzogZS5kYXRhIHx8IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBnZXRFbnY6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICBmKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbih7XG4gICAgICAgICAgICAgIG1pbmlwcm9ncmFtOiBcIm1pbmlwcm9ncmFtXCIgPT09IGUuX193eGpzX2Vudmlyb25tZW50XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGIgPSAxLFxuICAgIFIgPSB7fTtcbiAgICByZXR1cm4gUy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIU0pIHtcbiAgICAgICAgdmFyIG4gPSBlLnRhcmdldCxcbiAgICAgICAgaSA9IG4udGFnTmFtZSxcbiAgICAgICAgdCA9IG4uc3JjO1xuICAgICAgICBpZiAoKFwiSU1HXCIgPT0gaSB8fCBcIlZJREVPXCIgPT0gaSB8fCBcIkFVRElPXCIgPT0gaSB8fCBcIlNPVVJDRVwiID09IGkpICYmIC0xICE9IHQuaW5kZXhPZihcInd4bG9jYWxyZXNvdXJjZTovL1wiKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKSxcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHZhciBvID0gbltcInd4LWlkXCJdO1xuICAgICAgICAgIGlmIChvIHx8IChvID0gYisrLCBuW1wid3gtaWRcIl0gPSBvKSwgUltvXSkgcmV0dXJuO1xuICAgICAgICAgIFJbb10gPSAhMCxcbiAgICAgICAgICB3eC5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHd4LmdldExvY2FsSW1nRGF0YSh7XG4gICAgICAgICAgICAgIGxvY2FsSWQ6IHQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBuLnNyYyA9IGUubG9jYWxEYXRhXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgITApLFxuICAgIFMuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIU0pIHtcbiAgICAgICAgdmFyIG4gPSBlLnRhcmdldCxcbiAgICAgICAgaSA9IG4udGFnTmFtZTtcbiAgICAgICAgbi5zcmM7XG4gICAgICAgIGlmIChcIklNR1wiID09IGkgfHwgXCJWSURFT1wiID09IGkgfHwgXCJBVURJT1wiID09IGkgfHwgXCJTT1VSQ0VcIiA9PSBpKSB7XG4gICAgICAgICAgdmFyIHQgPSBuW1wid3gtaWRcIl07XG4gICAgICAgICAgdCAmJiAoUlt0XSA9ICExKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAhMCksXG4gICAgbiAmJiAoZS53eCA9IGUualdlaXhpbiA9IE4pLFxuICAgIE5cbiAgfVxufSk7Il0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFBQTtBQXFCQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBeEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBbUNBO0FBQ0E7QUFDQTtBQXJDQTtBQXVDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBdENBO0FBNkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBNUNBO0FBQUE7QUF5REE7QUFEQTtBQXhEQTtBQTREQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUVBO0FBR0E7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQVhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQXBUQTtBQXNUQTtBQUVBO0FBREE7QUFJQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBREE7QUFJQTtBQUVBO0FBQ0E7QUFEQTtBQUlBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBRUE7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFXQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFJQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUF4RUE7QUF6ZUE7QUFBQTtBQXNqQkE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n')}]]);